{"pages":[{"title":"404","text":"404 了…，返回首页","link":"/404.html"},{"title":"关于我","text":"DavidNode.js 前/后端开发Email: console.log(atob(&quot;bHZkYXdlaTE5NzBbYXRdZ21haWwuY29t&quot;))简介Node.js 技术栈前后端开发热衷响应式 CSS 布局，擅长像素级还原设计稿会用的前端框架：React会用的后端语言：Node.js / Java会用的数据库：MySQL其他在用：Nginx / Redis / 阿里云ESC / RDS工作经历** - 高级软件开发工程师 [ 2015-04 ~ 至今 ]在线教育平台一个在线英语课程试听、订购、学习、分享平台，含音视频学习、背单词、考试等功能技术栈：前端 React / Redux，后端 Node.js / Express / MySQL / Redis / Nginx主导后端接口&amp;数据库设计，负责整站服务部署运维负责前端重要入口页面开发，全站支持响应式布局，同时适配手机/平板/PC负责前端基础组件设计，供初级开发人员使用，加快项目开发进度负责 webpack 多页面脚手架搭建后台管理系统技术栈：前端 AngularJS / Vue负责实现包含用户/角色/权限/课程/订单/优惠券/微信分享等功能开发开发出单表快捷维护功能，实现根据表结构一键生成对应单表的增删改查页，节省大量开发时间** - JavaWeb 开发工程师 [ 2014-09 ~ 2015-04 ]电信号码百事通 O2O 便民平台技术栈：J2EE / jQuery / EasyUI负责对接派单接口&amp;操作界面，实现话务员向商户派发修家电、送煤气、上门保洁等便民订单流程** - JavaWeb 开发工程师 [ 2013-05 ~ 2014-06 ]电信运营商在线计费系统 CBS3.3技术栈：J2EE / jQuery / 内部自研前端框架负责 WebService 接口开发参与营业厅操作员业务受理界面开发，含充值、开户、订购套餐等业务流程参与测试环境部署、数据库排障&amp;备份教育经历扬州大学 - 本科 - 电子信息技术 [ 2009-09 ~ 2013-06 ]个人博客：https://dawei.lvGithub：https://github.com/daweilv","link":"/about/index.html"},{"title":"前端标准规范参考网站","text":"HTML标准规范https://html.spec.whatwg.org/CSSCSS标准规范https://www.w3.org/Style/CSS/current-workhttps://www.w3.org/TR/CSS/https://www.w3.org/TR/CSS22/Overview.htmlCSS Flexible Box Layout Module Level 1https://www.w3.org/TR/css-flexbox-1/Block formatting contexts(BFC)/ Inline formatting contextshttps://www.w3.org/TR/CSS2/visuren.html#normal-flowhttps://drafts.csswg.org/css-display/#block-formatting-contextJavaScriptJavaScript/ECMAScript/ES6标准规范http://www.ecma-international.org/ecma-262/6.0/ES5标准规范http://www.ecma-international.org/ecma-262/5.1/index.htmlES5标准规范（中文）https://www.w3.org/html/ig/zh/wiki/ES5HTTPHypertext Transfer Protocol – HTTP/1.1 标准规范https://tools.ietf.org/html/rfc2616Uniform Resource Locators (URL) 标准规范https://tools.ietf.org/html/rfc1738","link":"/spec/index.html"}],"posts":[{"title":"API设计总结","text":"本文总结了笔者近几年在参与设计 API 时收获的一些经验和教训，针对中小型项目初期，供大家参考。设计 基础数据与用户数据尽量分离。分别用不同的字段存储或直接分到不同的 API里。逻辑解耦，便于后期修改，也便于优化打开速度。123456// bad{ title:\"新概念英语\", image:\"http://example.com/en.png\", learnProgess:80}12345678910// good{ baseData:{ title:\"\", image:\"http://example.com/en.png\" }, userData:{ learnProgess:80 }}设计 鉴权数据能放 header 尽量放 header。不要往 GET/POST 请求参数里放。设计 公共请求参数/响应参数提前设计，预留空间以备升级。设计 原则上严格参考 GET/POST 的语义规范（GET 幂等，POST 提交数据）。之前一个项目采用了全 POST 请求，后期复盘后认为是一个比较失败的设计。公共参数都放在 POST 请求体里，无法修改成 GET 请求，导致做 PWA 的时候处处受限，并且也没有充分利用 GET 请求的强制缓存/协商缓存功能。1234567891011// bad{ \"channel\":\"\", \"locale\":\"zh_CN\", \"appver\":\"1.2.3\", \"token\":\"mytoken123\", \"sitecode\":\"sitecode567\", \"data\":{ \"id\":123 }}开发 后端开发的时候根据项目实际规模预留合理的升级空间，切勿考虑过多导致过度设计，冗余代码。开发 复杂逻辑在对性能没有极端要求的情况下，适当将并发操作改为串行，降低代码的阅读成本，或使用 async 流程控制库，在适当增加代码冗余的情况下，降低代码的阅读成本。开发 文件名、变量名严禁单字母缩写。如，wQuizAction.js/uOrderReducer.js 等，当时写的时候也许觉得很清晰，但是给其他阅读代码的人造成很大障碍，即使是本人在查看几个月前的代码也很可能忘记缩写的含义。数据库 用户相关的表在设计初级必须评估规模，根据可能出现的查询条件建索引，减少慢SQL。另外使用阿里云RDS的用户也可以经常查看下后台日志。数据库 数据库的字段尽可能与业务代码保持一致，重构时也要考虑重构完全。","link":"/2019/05/29/API-design/"},{"title":"Mac 键盘按键符号对照，Mac 新手必看","text":"先来看看我们最常用的五大修饰键⌘ 对应按键 Command ，这个最好记，因为键盘上就有⌥ 对应按键 Option⇪ 对应按键 Caps Lock⇧ 对应按键 Shift⌃ 对应按键 Control如果你用的是 Windows 标准键盘，请用 Alt 键代替 Option 键，用 Windows 标志键代替 Command 键。按键符号对照表修饰键符号Apple symbolCommand⌘Option (Alt, Alternative)⌥Caps Lock⇪Shift⇧Control⌃Return↩Forward Delete⌦Page Up⇞Page Down⇟Top (Home)↖End↘Tab Right⇥Tab Left⇤Eject⏏Escape (Esc)⎋试试 ⇧ + ⌥ + K （ Shift + Option + K ）会发生什么：）技巧Command+Shift+. 可以显示隐藏文件、文件夹，再按一次，恢复隐藏。finder下使用 Command+Shift+G 可以前往任何文件夹，包括隐藏文件夹。","link":"/2016/07/18/mac-keyboard/"},{"title":"Linux 服务器首次快速配置","text":"对应 linux 版本：Ubuntu 14.04.4 LTS (GNU/Linux 3.13.0-86-generic x86_64)拿到新服务器后的快速配置方案，供参考。修改 root 默认密码用 root 登录，输入1passwd提示输入新的密码，重复两次12Enter new UNIX password:Retype new UNIX password:看到下面的提示即表示修改成功了。1passwd: password updated successfully修改 ssh 默认端口号执行命令1vi /etc/ssh/sshd_config将下面的 Port 22 改为你想要设置的端口号（如 2333）123456# Package generated configuration file# See the sshd_config(5) manpage for details# What ports, IPs and protocols we listen forPort 22# Use these options to restrict which interfaces/protocols sshd will bind to保存文件后，执行下面的命令重启 ssh 服务1service ssh restart验证 root 密码和端口号修改生效执行命令退出服务器1exit在客户端命令行中执行（其中 example.com 为你的服务器域名或 ip 地址）1ssh -p 2333 root@example.com输入刚刚设置的新密码，就能看到欢迎信息了。123Welcome to Ubuntu 14.04.4 LTS (GNU/Linux 3.13.0-86-generic x86_64) * Documentation: https://help.ubuntu.com/ssh 保持连接（解决 Broken pipe 的问题）有时候我们客户端长时间不操作，再去操作的时候就会半天没反应，等一会后提示 broken pipe，下面的是博主的解决方法。客户端设置1vi /etc/ssh/sshd_config在最后添加两个参数12TCPKeepAlive yesServerAliveInterval 300第二个参数表示每过 5 分钟发一个数据包到服务器表示“我还活着”。服务器端设置如果在客户端修改过 ssh 设置后还遇到 broken pipe 的问题，那么就把服务器端的设置也修改一下吧。执行命令1vi /etc/ssh/sshd_config在最后增加一行12ClientAliveInterval 60ClientAliveCountMax 1作用是让 ssh server 发送“心跳”信号来维持持续连接。安装 mysql1apt-get update1sudo apt-get install mysql-server mysql-client安装过程中两次输入密码安装成功后执行命令，验证安装完成1service mysql restart1mysql -u root -p输入密码登录，后看到欢迎信息1234567891011Welcome to the MySQL monitor. Commands end with ; or \\g.Your MySQL connection id is 42Server version: 5.5.49-0ubuntu0.14.04.1 (Ubuntu)Copyright (c) 2000, 2016, Oracle and/or its affiliates. All rights reserved.Oracle is a registered trademark of Oracle Corporation and/or itsaffiliates. Other names may be trademarks of their respectiveowners.Type 'help;' or '\\h' for help. Type '\\c' to clear the current input statement.mysql 设置外网访问权限执行命令1vi /etc/mysql/my.cnf找到 bind-address =127.0.0.1 注释掉，使得不再只允许本地访问保存后执行命令1service mysql restart重新登录 mysql1mysql -u root -p1mysql&gt; use mysql;查询 host 值：123mysql&gt; select user,host from user;mysql&gt; update user set host='%' where user='root';mysql&gt; flush privileges;导出导入数据库12mysqldump -u root -p database_name &gt; dump.sqlpassword *****提前建好库12mysql -u root -p database_name &lt; dump.sqlpassword *****安装 nodejs1curl -sL https://deb.nodesource.com/setup_4.x | sudo -E bash -如果提示未安装 curl，执行 apt-get install curl1sudo apt-get install -y nodejs好了，到此我们的服务器的快速配置已经完成了。","link":"/2016/07/18/linux-setup/"},{"title":"MongoDB 在Shell中插入/更新的整数会变成浮点数","text":"从 shell 中更新/写入到文档的数字，会变为 float 类型引用：“shell 中的数字都被 MongoDB 当作是双精度数。这意味着如果你从数据库中获得的是一个 32 位整数，修改文档后，将文档存回数据库的时候，这个整数也就被换成了浮点数，即便保持这个整数原封不动也会这样的。”参考：《MongoDB 权威指南》第一版db.data.update({‘name’: ‘zero’}, {‘$set’: {‘value’: 0}})db.data.findOne({‘name’: ‘zero}){&apos;name&apos;: &apos;zero&apos;, &apos;value&apos;: 0.0} db.data.update({‘name’: ‘zero’}, {‘$set’: {‘value’: NumberInt(0)}})http://stackoverflow.com/questions/8218484/mongodb-inserts-float-when-trying-to-insert-integer","link":"/2016/09/01/insert-integer-into-mongodb-through-shell/"},{"title":"Progressive Web App 开发指南","text":"施工中坑点Service Workers 目前还没有被授予访问 cookie 的能力，viahttps://github.com/WICG/cookie-store/issues/37、https://github.com/w3c/ServiceWorker/issues/707、https://github.com/w3c/ServiceWorker/issues/837。所以通过 session 鉴权的页面可能会出现异常。","link":"/2018/06/27/pwa-dev-guide/"},{"title":"Prettier&ESLint集成","text":"1npm i -D eslint eslint-config-alloy eslint-config-prettier eslint-plugin-react prettier prettier-eslint.eslintrc.js1234567module.exports = { extends: [ 'eslint-config-alloy/react', 'eslint-config-prettier', 'eslint-config-prettier/react', ],};.prettierrc.js123456module.exports = { singleQuote: true, trailingComma: 'es5', semi: true, tabWidth: 4,};","link":"/2018/10/20/prettier-eslint-integration/"},{"title":"React与安卓/iOS通信实践","text":"安卓/iOS 可以调用 JS 侧的全局对象来完成通信，那么使用 React/Vue 的时候我们的方法都封装在框架内部，并没有暴露在全局，原生侧调不到框架内部的方法，怎么办？使用 EventEmitter！代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667import { eventEmmiter } from \"./eventEmmiter\";let Bridge = { // 统一接口请求参数&amp;类型，方便多平台调用 ios: function(event, params, needCallback = true) { return new Promise(resolve =&gt; { console.log( `invoke iOS.event[${event}] with params: ${JSON.stringify(params)}` ); if (!params) params = {}; const callbackEvent = this.getCallbackEvent(event); if (needCallback) { eventEmmiter.once(callbackEvent, res =&gt; { console.log(`callback iOS.event[${callbackEvent}] with data: ${res}`); if (res &amp;&amp; typeof res === \"string\") res = JSON.parse(res); resolve(res); }); } // 字符串化参数 let msg = JSON.stringify({ method: event, data: params, callback: callbackEvent }); console.log(`send iOS msg ${JSON.stringify(msg)}`); // native 为 wkwebview 注册的对象 webkit.messageHandlers.native.postMessage(msg); }); }, // 统一接口请求参数&amp;类型，方便多平台调用 android: function(event, params, needCallback = true) { return new Promise(resolve =&gt; { console.log( `invoke Android.event[${event}] with params: ${JSON.stringify(params)}` ); if (!params) params = {}; const callbackEvent = this.getCallbackEvent(event); if (needCallback) { eventEmmiter.once(callbackEvent, res =&gt; { console.log( `callback Android.event[${callbackEvent}] with data: ${res}` ); if (res &amp;&amp; typeof res === \"string\") res = JSON.parse(res); resolve(res); }); } let msg = JSON.stringify({ method: event, data: params, callback: callbackEvent }); console.log(`send Android msg ${JSON.stringify(msg)}`); // Android 为安卓侧注册的对象 Android[event](msg); }); }, // 生成随机事件，防止多次点击重复调用 getCallbackEvent: function(event) { return ( event + \"-\" + new Date().getTime() + \"-\" + (Math.random() * 100).toFixed() ); }};export default Bridge;JS 向原生请求消息，并接受回调JS 侧注册 EventEmitter 事件，给原生发消息和当前事件，当原生返回消息的时候，调用当前事件的回调，并将数据返回。12345678910111213141516// 根据 URL 约定的字段来判断当前在什么平台// eg: /detail/123?sitecode=ios// 调用时根据平台调用 Bridge.ios / Bridge.androidif (inIOSAPP()) { // 给 iOS 侧发登录请求，iOS侧弹出原生登录页，完成登录后回调 Bridge.ios(LOGIN_EVENT).then(res =&gt; { // save user info });} else if (inAndroidAPP()) { Bridge.android(LOGIN_EVENT).then(res =&gt; { // save user info });} else { // 原生浏览器，弹出登录框 this.toggleLoginModal();}原生向 JS 请求消息JS 侧注册 EventEmitter 事件，原生调用当前事件的回调，并将数据返回。12345componentDidMount() { eventEmmiter.on(SOME_EVENT, (res) =&gt; { console.log(res) });}","link":"/2018/08/23/communicate-between-react-android-ios/"},{"title":"Terminal 设置 path、alias","text":"1vi ~/.bash_profile123alias rn='react-native'alias ro='react-native run-ios'export PATH=$PATH:/usr/local/mysql/bin1esc1:wq!1source ~/.bash_profile","link":"/2016/12/09/set-terminal-path-alias/"},{"title":"bash 命令行常用快捷键整理","text":"编辑命令命令解释Ctrl + a移到命令行首Ctrl + e移到命令行尾Ctrl + f按字符前移（右向）Ctrl + b按字符后移（左向）Alt + f按单词前移（右向）Alt + b按单词后移（左向）Ctrl + xx在命令行首和光标之间移动Ctrl + u从光标处删除至命令行首Ctrl + k从光标处删除至命令行尾Ctrl + w从光标处删除至字首Alt + d从光标处删除至字尾Ctrl + d删除光标处的字符Ctrl + h删除光标前的字符Ctrl + y粘贴至光标后Alt + c从光标处更改为首字母大写的单词Alt + u从光标处更改为全部大写的单词Alt + l从光标处更改为全部小写的单词Ctrl + t交换光标处和之前的字符Alt + t交换光标处和之前的单词Alt + Backspace与 Ctrl + w 类似，分隔符有些差别Ctrl + r逆向搜索命令历史Ctrl + g从历史搜索模式退出Ctrl + p历史中的上一条命令Ctrl + n历史中的下一条命令Alt + .使用上一条命令的最后一个参数控制命令命令解释Ctrl + l清屏Ctrl + o执行当前命令，并选择上一条命令Ctrl + s阻止屏幕输出Ctrl + q允许屏幕输出Ctrl + c终止命令Ctrl + z挂起命令","link":"/2016/07/19/useful-bash-command/"},{"title":"Webpack4.0 升级配置","text":"本文基于 webpack 4.8.1吐槽webpack 彪版本号的速度真是飞快，4.0 发布没多久上去看的时候才 4.1.*，现在已经刷到 4.8.1 了，给人一种“我版本号很高了，可以安心升级了”的感觉，然而坑依然很多…尤其是 API 文档，到处可见 3.0 的陈旧信息。Code Splitting 章节点进去依然在讲 CommonsChunkPlugin ，CommonsChunkPlugin 点进去提示去看 SplitChunksPlugin，看文档的时候经常会迷失自我，心累…好了，吐槽完毕，下面是正文。需要直接复制粘贴的同学直接拉到最后~4.0 与 3.0 的区别modewebpack4.0 新增了 mode 的概念, mode 可以为 development、production 和 none。development 帮我们设置了 process.env.NODE_ENV=development，并添加了 NamedModulesPlugin 插件。process.env.NODE_ENV=development 可以用来显示一些在开发模式下才显示的 debug 信息，请注意这个 NODE_ENV 不能在 webpack.config.js 中使用，只能在你的源文件中使用。想要在 webpack.config.js 中也生效，需要在 package.json 的 script 脚本前添加 NODE_ENV=development，如 NODE_ENV=development webpack --config webpack.dev.js。NamedModulesPlugin 是在开启 HMR 的时候使用的插件。12345678// webpack.development.config.jsmodule.exports = {+ mode: 'development'- plugins: [- new webpack.NamedModulesPlugin(),- new webpack.DefinePlugin({ \"process.env.NODE_ENV\": JSON.stringify(\"development\") }),- ]}production 帮我们设置了 process.env.NODE_ENV=production，并添加了 UglifyJsPlugin、ModuleConcatenationPlugin、NoEmitOnErrorsPlugin 等插件，在设置了 sideEffects=false 之后可以实现未引用代码删除的功能。12345678910// webpack.production.config.jsmodule.exports = {+ mode: 'production',- plugins: [- new UglifyJsPlugin(/* ... */),- new webpack.DefinePlugin({ \"process.env.NODE_ENV\": JSON.stringify(\"production\") }),- new webpack.optimize.ModuleConcatenationPlugin(),- new webpack.NoEmitOnErrorsPlugin()- ]}optimization另一个区别在于引入了 optimization 的概念，optimization.minimizer 和 optimization.splitChunks 是需要我们关注的两个配置。optimization.minimizer 用于指定 webpack 使用哪个代码压缩插件，默认为 new webpack.optimize.UglifyJsPlugin，推荐更换为 UglifyJSPlugin。1234567891011+const UglifyJSPlugin = require('uglifyjs-webpack-plugin');module.exports = { //... optimization: { minimizer: [- new webpack.optimize.UglifyJsPlugin({})+ new UglifyJSPlugin({}) ] }}optimization.splitChunks 替代了 3.0 的 CommonsChunkPlugin，实现公共代码抽取。具体 API 参见SplitChunksPlugin。划几个重点，webpack 生成已经给大部分用户提供了默认的设置，mode=production 就已经带了这个优化，BUT!! 默认开启的代码分割只对异步加载的代码有效，也就是如果你是多个入口的配置，那么你的 react、react-dom、react-router 等公共库以及你的 common 代码都会被重复打包进多个入口里。emmmmm，这叫什么开箱即用嘛，还是我们自己动手吧。首先，optimization.splitChunks.chunks 设置为 all，使得 async 异步加载的代码和 initial 初始化的代码都会被抽取。optimization.splitChunks.cacheGroups 添加 commons 和 vendors （如下）。1234567891011121314151617181920212223module.exports = { optimization: { splitChunks: { chunks: \"all\", cacheGroups: { commons: { name: \"commons\", test: /src[\\/]/, chunks: \"initial\", priority: 2, minChunks: 2 }, vendors: { name: \"vendors\", test: /node_modules/, chunks: \"initial\", priority: 10, minChunks: 2 } } } }};这里的 name 指定你要抽取出来的 js 的文件名，test 字段用来筛选你要匹配的代码，minChunks:2 表示代码被引用 2 次及以上就会被抽取出来，commons 实现抽取你的 src 文件夹下的公共代码，vendors 则用于抽取 node_modules 下的公共库。下面我们需要把我们抽取出来的 commons.js 和 vendors.js 添加到 HtmlWebpackPlugin ，以实现打包出来的 html 文件引用 commons.js 和 vendors.js。12345new HtmlWebpackPlugin({ //...- chunks: 'index',+ chunks: ['vendors', 'commons', 'index'],})到笔者发布文章为止，HtmlWebpackPlugin 还不支持添加动态名称的 cacheGroups，无法将未明确指定 name 的 vendors~chunk-a~chunk-b.js 之类的 js 打包进代码中，不过可以看到相关的代码已经快要出来了。之后就可以实现更精细的代码分割打包了。plugins使用 mini-css-extract-plugin 替代 extract-text-webpack-plugin抽取 css 到单独文件中，使用 optimize-css-assets-webpack-plugin 对 css 进行压缩处理。optimize-css-assets-webpack-plugin 在使用的时候强烈推荐设置 isSafe = true，避免 z-index 被修改的问题。12345new OptimizeCSSAssetsPlugin({ cssProcessorOptions: { isSafe: true }});最后webpack4-demo 是笔者整理的 webpack4.0 demo，详细的 webpack 配置可以在这里找到。支持开发/生产模式支持开发模式下 HMR支持代码分割、代码混淆压缩支持未引用代码删除支持 less、autoprefixer支持单/多入口支持查看打包各个模块占用大小","link":"/2018/05/21/upgrade-to-webpack4/"},{"title":"bind 实现","text":"用法MDN bind极简实现123456Function.prototype.bind = function(obj, ...args) { var fn = this; return function() { return fn.apply(obj, args) }}简易实现12345678910111213141516171819// Does not work with `new funcA.bind(thisArg, args)`if (!Function.prototype.bind) (function(){ // Is this an error? We are invoking &lt;call.bind&gt; method before it's defined. var slice = Array.prototype.slice.call.bind(Array.prototype.slice); Function.prototype.bind = function() { var thatFunc = this, thatArg = arguments[0]; var args = slice(arguments, 1); if (typeof thatFunc !== 'function') { // closest thing possible to the ECMAScript 5 // internal IsCallable function throw new TypeError('Function.prototype.bind - ' + 'what is trying to be bound is not callable'); } return function(){ var funcArgs = args.concat(slice(arguments)) return thatFunc.apply(thatArg, funcArgs); }; };})();复杂实现12345678910111213141516171819202122232425262728293031// Yes, it does work with `new funcA.bind(thisArg, args)`if (!Function.prototype.bind) (function(){ var ArrayPrototypeSlice = Array.prototype.slice; Function.prototype.bind = function(otherThis) { if (typeof this !== 'function') { // closest thing possible to the ECMAScript 5 // internal IsCallable function throw new TypeError('Function.prototype.bind - what is trying to be bound is not callable'); } var baseArgs= ArrayPrototypeSlice .call(arguments, 1), baseArgsLength = baseArgs.length, fToBind = this, fNOP = function() {}, fBound = function() { baseArgs.length = baseArgsLength; // reset to default base arguments baseArgs.push.apply(baseArgs, arguments); return fToBind.apply( fNOP.prototype.isPrototypeOf(this) ? this : otherThis, baseArgs ); }; if (this.prototype) { // Function.prototype doesn't have a prototype property fNOP.prototype = this.prototype; } fBound.prototype = new fNOP(); return fBound; };})();参考实现https://github.com/Raynos/function-bind/blob/master/implementation.js","link":"/2019/09/05/build-your-own-bind/"},{"title":"cloc,一个好用的代码统计小工具","text":"最近公司在做双软认证，需要提供一下源码的行数，网上找了一番，发现一个非常不错的小工具，故分享下。简介cloc，即 Count Lines of Code 的缩写，支持统计众多编程语言源码的空行数、注释行数、物理行数。安装非常简单。直接 npm install -g cloc 即可。其他安装方法见 Install via package manager。用法：统计单个文件的行数sample.js12345678910function hello() { // comments console.log('hello world') }hello()1234567891011121314# 运行cloc sample.js# 返回结果 1 text file. 1 unique file. 0 files ignored.github.com/AlDanial/cloc v 1.78 T=0.01 s (76.2 files/s, 762.0 lines/s)-------------------------------------------------------------------------------Language files blank comment code-------------------------------------------------------------------------------JavaScript 1 5 1 4-------------------------------------------------------------------------------字段含义files文件数blank空行数comment注释行数code代码行数统计目录下的源码行数123456789101112131415161718192021222324252627282930313233343536373839404142434445# 运行clol .# 返回结果 17754 text files. 12969 unique files. Complex regular subexpression recursion limit (32766) exceeded at /Users/user/.nvm/versions/node/v8.12.0/bin/cloc line 10685.Complex regular subexpression recursion limit (32766) exceeded at /Users/user/.nvm/versions/node/v8.12.0/bin/cloc line 10685. 5797 files ignored.github.com/AlDanial/cloc v 1.78 T=35.80 s (335.9 files/s, 77895.9 lines/s)---------------------------------------------------------------------------------------Language files blank comment code---------------------------------------------------------------------------------------JavaScript 8763 192138 281252 1465456JSON 1403 756 0 327584Markdown 1093 52708 4 134228TypeScript 85 14720 34711 115732HTML 231 47061 580 51339CSS 90 3165 1207 26616XML 56 3246 1300 13713C/C++ Header 21 1147 341 5913YAML 120 105 128 2711SQL 30 411 374 2249CoffeeScript 17 198 112 1111Protocol Buffers 51 245 739 719make 23 213 188 676DTD 1 179 177 514Windows Module Definition 5 88 0 437Python 1 81 175 355C++ 7 70 36 317JSP 3 27 44 273ActionScript 1 38 102 132JSON5 2 0 0 123D 5 0 0 71Bourne Shell 5 25 7 53Handlebars 2 10 0 46EJS 3 6 0 27Vuejs Component 4 0 4 21Bourne Again Shell 1 2 1 20Lisp 1 0 0 6DOS Batch 1 0 0 2---------------------------------------------------------------------------------------SUM: 12025 316639 321482 2150444---------------------------------------------------------------------------------------","link":"/2018/12/11/cloc-code-analysis/"},{"title":"React相关推荐文章","text":"why is setState asynchronous?https://github.com/facebook/react/issues/11527#issuecomment-360199710When and why are setState() calls batched?https://stackoverflow.com/questions/48563650/does-react-keep-the-order-for-state-updates/48610973#48610973Dive into React codebase: Transactionshttps://reactkungfu.com/2015/12/dive-into-react-codebase-transactions/15.0 stable versionhttps://github.com/facebook/react/tree/15-stablehttps://engineering.hexacta.com/didact-learning-how-react-works-by-building-it-from-scratch-51007984e5c5React Fiber Architecturehttps://github.com/acdlite/react-fiber-architectureStill don’t understand why you need Redux? Read this…https://almerosteyn.com/2016/08/redux-explained-again","link":"/2019/09/26/react-recommend-article/"},{"title":"eventloop","text":"macrotasks: setTimeout, setInterval, setImmediate, I/O, UI renderingmicrotasks: process.nextTick, Promises, Object.observe(废弃), MutationObserverpromise/a+ 规范 https://promisesaplus.com/#noteshttps://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/https://juejin.im/entry/58d4df3b5c497d0057eb99ffhttps://html.spec.whatwg.org/multipage/webappapis.html#task-queuehttps://blog.bitsrc.io/microtask-and-macrotask-a-hands-on-approach-5d77050e2168https://www.youtube.com/watch?v=8aGhZQkoFbQhttps://github.com/ccforward/cc/issues/48https://github.com/creeperyang/blog/issues/21","link":"/2019/09/05/event-loop-intro/"},{"title":"git&npm设置proxy","text":"Npm 设置 proxy123456npm config set proxy http://127.0.0.1:1087npm config set https-proxy http://127.0.0.1:1087# 需要认证的 proxynpm config set proxy http://username:password@server:portnpm config set https-proxy http://username:pawword@server:portNpm 取消 proxy12npm config rm proxynpm config rm https-proxyGit 设置给特定url设置 proxy123456git config --global http.proxy http://127.0.0.1:1087git config --global https.proxy https://127.0.0.1:1087# 只对github.comgit config --global http.https://github.com.proxy http://127.0.0.1:1087git config --global https.https://github.com.proxy https://127.0.0.1:1087Git 取消 proxy12git config --global --unset http.https://github.com.proxygit config --global --unset https.https://github.com.proxy","link":"/2019/01/11/set-git-npm-proxy/"},{"title":"javascript 正则表达式的那些坑","text":"js 正则，匹配多行的[.\\n] 不能拿来匹配多行， [] 里的 . 会被解析成标点符号，而不是任意字符","link":"/2016/12/09/regexp-in-js/"},{"title":"javascript audio 对象常用事件","text":"最近在做一个媒体播放器，集成了图片+音频播放模式和视频播放模式，研究了下 js audio 对象的事件，整理了相关事件及触发顺序。音频的初始加载事件顺序：依次触发 onloadstart、onprogress、onsuspend，然后 onprogress、onsuspend 交替触发，直到触发 ondurationchange、onloadedmetadata、onloadeddata、oncanplay、oncanplaythrough，加载完成。点击播放后触发事件顺序：onplay、onplaying、ontimeupdate，播放控件开始缓冲部分音频文件onprogress，缓冲足够多的音频片段后触发onsuspend，当缓冲即将播放完后又触发onprogress、onsuspend，依次循环直到音频全部缓冲完毕。音频播放完毕后触发：onpause、onended暂停播放控件时触发：onpause从暂停恢复播放后触发：onplay、onplaying","link":"/2017/04/25/common-event-in-audio/"},{"title":"npm 版本号主要注意的规则","text":"一直都觉得 npm 版本号没什么好注意的，直到今天掉到坑里了，爬了一下午才爬出来，特作此文，加深印象，提醒自己。某日，用的好好的 Webpack 突然打出来的包某个 entry 不能用了，一直报错 Uncaught TypeError: Cannot read property 'call' of undefined 。代码一顿分析没找到原因，去 Webpack Issue 上搜了一把，还真有不少遇到相同问题的(7499、7425)。官方维护人员给出的反馈是暂未定位到具体原因，翻看了下面的反馈，有人指出使用 4.9.2 以上的版本都会有问题。So，cnpm i -D webpack@4.9.2 尝试安装了 4.9.2 的版本，重新打包，问题不再重现，问题解决，提交新的 package.json，美滋滋。But，还没安稳多久。同事 Kim 表示自己的项目打出来的包还是不正常。怎么会这样呢，我们俩的项目都是一样的，代码都是最新的。于是我重新打包了一次项目，没能重现。于是 rm -rf node_modules，重新 cnpm i，自信打包。问题复现…What？！怎么会？包不都是一样的吗？笔者一顿猛删 node_modules，下载了各种 webpack 版本，各种 cnpm i，发现打包时好时坏，怎么回事呢？这时一道灵光闪过，会不会是 node_modules 下的包版本不一致呢？仔细对比了同事的 node_modules 发现，他的 webpack 居然是 4.12.0 的！为什么呢？笔者突然想起来，package.json 里面的配置是：1234567{ // ... \"devDependencies\": { // ... \"webpack\": \"^4.9.0\" }}请注意这个 ^ ，罪魁祸首就是这个 ^！它的含义是 不低于当前版本主版本号的最新版本。也就是说，如果当前 webpack 最高版本 4.12.0 ，那么你的 ^4.9.0 会去下载 4.12.0，也就是当前的问题版本，而不是 4.9.0！这也解释了为什么我主动 cnpm i -D webpack@4.9.2 的时候打包正常，而删除 node_modules 重新打包就会出现问题，两种操作下下来的 webpack 版本不一致嘛！问题定位出来后，我们修改了 package.json，在官方修复该问题之前先锁定版本号：12345678{ // ... \"devDependencies\": { // ...- \"webpack\": \"^4.9.0\",+ \"webpack\": \"4.9.0\", }}重新安装&amp;打包，问题不再重现，bug fix！附 npmjs 官网对语义化符号的说明 https://semver.npmjs.com/。","link":"/2018/06/21/version-control-in-npm/"},{"title":"parcel初体验","text":"最近需要做一个纯静态网站，因工作量比较少，功能又不复杂，上 webpack 觉得太麻烦了，加上早就对 parcel 种草，所以这次决定试用一下号称零配置的 parcel 。上手根据官网文档很快就安装好了。值得点赞的是，在引入 less 文件的时候，parcel 自动检测到了 less，并自动下载了相关编译插件，稍等片刻即可使用。打包速度挺快，HMR 也是挺好用。深度使用路径修改很快定制需求来了，由于 HTML 文件内的相对路径都自动转换成了 dist 下的绝对路径，而我需要能在不启动服务器的情况下，在本地直接打开 index.html 预览。那么就需要将 HTML 内的资源路径都转换成相对路径。查询文档后发现指定 --public-url 即可。1parcel build src/page/index.html --public-url ./postcss 插件引入由于需要支持响应式，所以进入了 rem 单位，为了省事引入了 postcss-pxtorem 插件，能够自动将 px 转换成 rem。123456# postcss.config.jsconst pxtorem = require('postcss-pxtorem');module.exports = { plugins: [pxtorem({ rootValue: 50, propList: ['*'] })],};深坑HMR less 修改后不自动加载在特定的某个页面下，我修改了 less 文件，parcel 在编译后，浏览器并没有刷新样式。style appearance 无法加上厂商前缀正常情况下，appearance: none;会被编译成 -webkit-appearance: none;-moz-appearance: none;appearance: none; ，但是 parcel 并没有转换。一开始我以为是 browserslist 的问题，在查询了 autoprefixer 文档后发现，autoprefixer 没问题。所以问题就出在 parcel 上。引入指定 autoprefixer ，覆盖掉 parcel 的 autoprefixer 问题解决。1234567# postcss.config.jsconst pxtorem = require('postcss-pxtorem');const autoprefixer = require('autoprefixer');module.exports = { plugins: [autoprefixer, pxtorem({ rootValue: 50, propList: ['*'] })],};打包目录反人类第一次把项目打包出来后看了下目录，惊了个呆，居然所有文件平铺在 dist 目录下。。。一个合理的目录至少要把 css/img/font 等资源分门别类放在对应文件夹下，在深入了解了下之后，发现居然不能改，还发现了另外一个深坑。dist 下的文件无法取消 hash作为演示 demo 页面，我对强缓存没有需求，所以我不需要对我的资源进行 hash 重命名，这样也不够美观。翻了一遍 issue 后发现，由于打包目录的原因，同名文件可能出现在dist下，所以 hash 文件名策略不能取消。好消息是 parcel 2 会通过插件的方式支持命名策略。https://github.com/parcel-bundler/parcel/issues/233#issuecomment-435718097总结parcel 作为一个新前端编译工具，带来了零配置的概念，轻度尝鲜很棒。但是作为生产使用的时候，还有不少 bug 和缺点，gulp&amp;webpack 等成熟的插件往往没有对应的文档，目前来讲并不推荐作为生产工具使用。","link":"/2019/02/15/first-use-parcel/"},{"title":"text-size-adjust bug 分析","text":"某日，同事 J 说发现一个奇怪的现象：一个列表页，在 iPhone7 竖屏上字体大小正常，横屏的时候有些字体就变的特别大。本文便是笔者对这一 “bug” 的分析过程。拿到那个页面，在 MacOS Chrome 下模拟了 iPhone7 的设备，发现横竖屏都是正常的。又在自己的手机上测了一下，果然重现了。如下图：因为这个页面是响应式页面，对手机横版做了适配，笔者猜测可能是对应的样式没应用上。但转念一想，不对啊，就算是样式没应用上，也应该是整个列表都有问题，不可能就那一个 item 字体有问题。在调试了几次样式无果后，笔者猜测是 webkit 对字体在某种情况下的“人性化智能”缩放导致，类似桌面端的 Chrome 对 12px 以下字体的限制，具体是什么原因导致的不知道。Google 一番发现有个属性很可能是导致这个 bug 原因：text-size-adjust。引用 MDN 上对 text-size-adjust 的解释：text-size-adjust 属性 允许我们控制将文本溢出算法应用到一些手机设备上。这个属性还没有写进标准，使用时必须加上前缀：-moz-text-size-adjust，-webkit-text-size-adjust,，和 -ms-text-size-adjust。因为缩放适配小屏幕而导致文字会变得很小，许多手机浏览器会使用文本溢出算法让文本变大而更易读。当一个包含文本的元素宽度用了 100%，他的文本大小会增加直到达到一个易读的大小，但是不会修改布局。So? Feature not bug?????笔者尝试在 item 容器样式上加了一个 -webkit-text-size-adjust:none，发现样式正常了。到底是什么情况下 text-size-adjust 会自动调整呢？笔者写了几个例子，来还原这 bug，注意使用 iPhone 打开，并观察横竖屏：正常的列表，点击查看异常的列表，点击查看出现异常并被修复的列表，点击查看分析了一下 text-size-adjust 出现的可能情况：容器宽度为百分比，不光 100% 的时候；列表项中至少有 2 个元素应用了相同的字体，单个元素没有出现放大的效果；容器宽度比 viewport 的宽度大，不论是百分比 120% 还是固定值 px；修复的方法：设置一个比 viewport 窄的固定值；在外层样式上应用 text-size-adjust:none 或 text-size-adjust:100% ，两种设置等效，没有用 autoprefix 的同学记得加上厂商前缀，经测试，不带 -webkit 前缀的 text-size-adjust:none 是无效的。12345html { -ms-text-size-adjust: 100%; -webkit-text-size-adjust: 100%; text-size-adjust: 100%;}另外，text-size-adjust 在 iPhone 上默认值为 auto，iPad 上的默认值为 none，所以 iPad 并不会出现该 bug。参考：iPhone/iPod - prevent font-size-changingHow to prevent mobile devices to scale font sizeHow to avoid iOS automatic font size adjustment?Ask Question如何判断网页应用了哪些字体text-size-adjust: 100% 有什么作用？《CSS 工作流》","link":"/2018/07/28/text-size-adjust-bug/"},{"title":"vi 编辑器命令备忘","text":"打开一个文件1vi ~/.bash_profile跳到行首10跳到行尾1shift + 4","link":"/2016/12/09/vim-command/"},{"title":"使用 Webpack4.0 打包组件库并发布到 npm","text":"本文将会介绍如何将自己写的组件库打包成第三方库，发布到 npm 上，同时支持在原生 js / React/ Vue 下使用。Webpack4 的升级指南可以参考下 Webpack4.0 升级配置，本文不做赘述。使用 Webpack4.0 打包1234// src/index.jsexports default function Tree() { console.log('Hello Tree')}假设我们有上面的 index.js 文件，我们想要把打它打包成一个 tree.js 和一个 tree.min.js 包，并且我希望我既可以通过 &lt;script src=&quot;../dist/tree.js&quot;&gt;&lt;/script&gt; 直接 new Tree() ，又可以通过 import Tree from 'tree' 或 let Tree = require('tree') 引入，怎么做呢？这就要使用 Webpack 来处理了。Webpack 不仅可以打包 React / Vue 相关的项目工程，也可以单独打包 js 组件。先来看下入口与出口的配置：123456789101112131415module.exports = { //... mode: \"none\", entry: { tree: \"./src/index.js\", \"tree.min\": \"./src/index.js\" }, output: { filename: \"[name].js\", libraryExport: \"default\", library: \"Tree\", libraryTarget: \"umd\" } //...};modeWebpack4.0 会在默认情况下开启 mode=production，这会无差别的压缩我们的 tree.js 和 tree.min.js，这不是我们想要的，禁用它。entryentry 里面我们配置两个入口 tree、&quot;tree.min&quot;，让 webpack 可以打包出两个文件，我们可以针对两个入口做不同的处理。outputoutput 的 filename 表示打包出来文件名叫什么。libraryExport=default 表示打包出来的组件直接对外暴露 default 属性，否则我们调用的时候需要 new Tree.default()，这不是我们希望的调用方式。library=Tree 表示对外暴露的组件叫什么，如果这个地方修改成了 library=Bar，那我们调用的时候就是 new Bar()。libraryTarget=umd 表示采用 UMD (Universal Module Definition) 的方式打包 js，同时支持在 CommonJS、AMD 和全局变量使用。optimization怎么对 tree.min.js 压缩，但不对 tree.js 压缩呢？请看下面的配置部分：12345678910// ... optimization: { minimize: true, minimizer: [ new UglifyJSPlugin({ include: /\\.min\\.js$/, }), ], },// ...通过 include 设置只压缩 min.js 结尾的文件，是不是很简单。这样我们就得到了 dist/tree.min.js、dist/tree.js 两个文件。下面我们开始发布代码到 npm。发布组件库到 npm 上发布之前发布之前，还有件事需要做，在项目根目录新建 index.js，添加内容12345if (process.env.NODE_ENV === \"production\") { module.exports = require(\"./dist/tree.min.js\");} else { module.exports = require(\"./dist/tree.js\");}修改 package.json 的 main 为 index.js，指定我们通过 import / require 的时候入口文件位置。注册 npm想要发布代码到 npm 上，需要先注册一个账号，你可以直接打开官网注册，这里我们选择更 cooooool 的方式注册。1npm adduser依次输入 Username、Password、Email 完成注册。登录 npm注册好账号之后需要在 Terminal 上登录 npm，在 Terminal 中直接注册的同学就不需用登录了。1npm login输入 Username、Password、Email 完成登录。发布到 npm1npm publish发布的包名就是你的 package.json 的 name 和 version。有冲突的话需要换一个哦。最后本文其实是笔者近期在开源的一个树形选择控件 @widgetjs/tree 摸索出来的打包经验总结。为了简化配置，突出重点，省略了一些生产环境需要添加的较为繁琐的细节，正式的生产模式配置可以在 github 上找到，也欢迎使用，多多提出意见。","link":"/2018/06/08/pack-and-publish-js-library-use-webpack/"},{"title":"为你的阿里云服务器 ECS 升级 https","text":"本文是从零搭建-Node-js-线上环境的后续，因 https 比较独立，故单独写了一篇文章记录下。阿里云现在提供了免费的 SSL 证书，申请过程略过，很简单，审核通过后下载证书文件。在 /etc/nginx 下新建目录 cert，将证书 xxx.pem 和 xxx.key 上传到 /etc/nginx/cert 下，修改 dev.example.com.conf:1234567891011121314151617server { listen 443; server_name dev.example.com; access_log /var/log/nginx/dev.example.com.access.log; ssl on; #开启SSL ssl_certificate cert/xxx.pem; #证书文件 ssl_certificate_key cert/xxx.key; #私钥文件 location / { proxy_pass http://127.0.0.1:8888/; }}server { listen 80; #监听80端口 server_name dev.example.com; #监听的域名 return 301 https://dev.example.com$request_uri;}12# test 下配置有没有问题nginx -t12# 重新加载配置service nginx reload重新访问 http://dev.example.com 看看是不是已经跳转到 https://dev.example.com 了","link":"/2018/06/22/update-your-ecs-to-https/"},{"title":"从零实现一个 JS 模块打包器","text":"2019 年的前端技术栈，无论你是用 Vue 还是用 React ，应该都离不开一样工具 – webpack。webpack 极大的简化了前端开发的构建过程，只需提供一个入口文件，webpack 就能自动帮我们分析出相关依赖，构建出 bundle 包。webpack 很强大，但是大家知道 webpack 到底是怎么样打包的吗？本文将从一个很简单的例子，一步步带领大家探寻 webpack 打包的基本原理。一、准备阶段本文的代码详见webpack-mini step1。在本文中，我们不考虑任何优化操作，尽可能的保持代码最简单。假设我们的项目目录及文件列表如下，我们将使用命令 node webpack-mini/index.js 把 src 下的代码打包成一个 bundle.js 。12345678├── dist // 打包出来 bundle 文件所在目录│ ├── bundle.js├── src // 业务代码目录│ ├── bar.js│ ├── foo.js│ └── index.js // 入口文件└── webpack-mini // mini 打包器代码目录 └── index.js123456// src/index.jsimport foo from './foo.js';import { say } from './bar.js';foo();say();1234// src/foo.jsexport default function() { console.log('foo: Hello I am foo!');}1234// src/bar.jsexport const say = function() { console.log('bar.say: Hello I am bar!');}二、分析结构先来看入口文件， src/index.js 通过 ES6 的 import 语法引入了 foo 的 default 方法和 bar 的 say 方法。如何解析 index.js 、foo.js、bar.js 之间的依赖关系呢？字符串查找？不行，这样要考虑的边界情况太多。正则？也不行，同样很复杂。那么正统的处理方式是什么？语法解析。在这个 DEMO 中，我们使用 babel 来解析 JS 文件，生成抽象语法树。先看下 src/index.js 中的 import foo from './foo'; 通过在线语法解析网站 axtexplorer.net 生成的 json 结构（省略了部分无关节点信息）。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748{ \"type\": \"File\", \"start\": 0, \"end\": 24, \"loc\": {}, \"program\": { \"type\": \"Program\", \"start\": 0, \"end\": 24, \"loc\": {}, \"sourceType\": \"module\", \"body\": [ { \"type\": \"ImportDeclaration\", // 划重点 \"start\": 0, \"end\": 24, \"loc\": {}, \"specifiers\": [ { \"type\": \"ImportDefaultSpecifier\", // 划重点 \"start\": 7, \"end\": 10, \"loc\": {}, \"local\": { \"type\": \"Identifier\", \"start\": 7, \"end\": 10, \"loc\": {}, \"name\": \"foo\" } } ], \"importKind\": \"value\", \"source\": { \"type\": \"Literal\", \"start\": 16, \"end\": 23, \"loc\": {}, \"value\": \"./foo\", // 划重点 \"rawValue\": \"./foo\", \"raw\": \"'./foo'\" } } ] }, \"comments\": [], \"tokens\": []}我们的解析工具识别出了这是一个 import 声明（ImportDeclaration），并且是一个默认的声明（ImportDefaultSpecifier），声明标识符（Identifier）为 foo，引用的资源路径为 ./foo。解析工具帮我们把字符串代码转换为了结构化的对象，有了结构化的对象，我们就能进行下一步了。三、生成依赖图想要打包 JS 模块，先要拿到 JS 的依赖图，上图就是生成依赖图的流程图。下面我们看下具体代码实现：123456789101112131415161718192021222324252627282930313233343536373839const path = require('path');const { transformFileSync } = require('@babel/core');/** * 读取资源文件，修改 import 语句，ES6 import/export 语法转换成 require/exports 的形式，并生成依赖图 * @param {string} filePath - 资源文件路径 */function createGraph(filePath) { if (!path.isAbsolute(filePath)) filePath = path.resolve(__dirname, filePath); const dirPath = path.dirname(filePath); const dependencies = []; const visitor = { // 我们要修改的节点是 import 声明节点。 ImportDeclaration({ node }) { // 递归遍历 import 引用的资源文件，将相对路径转换为绝对路径，作为对应模块的 key node.source.value = path.resolve(dirPath, node.source.value); dependencies.push(createGraph(node.source.value)) } }; const { code } = transformFileSync(filePath, { presets: ['@babel/env'], plugins: [ { // babel 提供的访问者模式，详细解释可参考下文 // https://daweilv.com/2018/07/21/教练我想写一个-helloworld-Babel-插件/ visitor } ] }); return { filePath, code, dependencies }}这里需要说明的一点是，由于 ES6 import 的语法支持程度还很低，并且需要特殊的加载方式（ &lt;script type=&quot;module&quot;&gt; ），另外，我们后面还要兼容 commonjs 的 module.exports/exports 语法，所以我们需要用 @babel/env 转换一下代码。分别看下 src/index.js 和 src/foo.js 转换后的样子，下一步我们将使用转换后的代码，在 exports 上做文章。1234567891011121314151617181920// src/index.js\"use strict\";var _foo = _interopRequireDefault(require(\"/Users/david/project/webpack-mini/src/foo.js\"));var _bar = require(\"/Users/david/project/webpack-mini/src/bar.js\");// 这个方法是为了统一 commonjs 和 es module 的 default 语法// Modules in Common JS :// module.exports = function () {};//// Modules in ES6 :// export default function () {}function _interopRequireDefault(obj) { return obj &amp;&amp; obj.__esModule ? obj : { \"default\": obj }; }(0, _foo[\"default\"])();// 这种语法与 Object(_bar.say)() 实现效果相同，使得 _bar.say 作为函数调用// 而不是作为 _bar 的 say 方法，这与 es6 module 的 export 行为一致(0, _bar.say)();1234567891011121314// src/foo.js\"use strict\";Object.defineProperty(exports, \"__esModule\", { value: true});// export default function () {}// default function 被挂载到了 exports 上exports[\"default\"] = _default;function _default() { console.log('foo: Hello I am foo!');}四、生成 bundle 文件拿到依赖图后，我们就要开始组装 bundle 包了。先遍历一遍依赖图，将依赖图转为数组，方便下一步生成入口文件的时候使用。12345678910111213141516/** * 递归遍历，将依赖图展开成平级的数组 * @param {object} graph - 依赖图 * @param {array} modules - 展开后的数组 */function flattenGraph(graph, modules) { if (!modules) modules = []; // 这里将文件的绝对路径作为 module 的id modules.push({ id: graph.filePath, code: graph.code }) if (graph.dependencies.length) { graph.dependencies.forEach(o =&gt; { flattenGraph(o, modules) }) } return modules}拿到模块数组后，开始拼接代码块。12345678910111213141516/** * 生成入口文件，拼接模块数组 * @param {array} modules 模块数组 */function createBundle(modules) { return `(function (modules) { function require(moduleId) { let exports = {}; modules[moduleId](exports, require); return exports; } require(\"${modules[0].id}\")})({${modules.map(module =&gt; (`\"${module.id}\":${generateModuleTemplate(module.code)}`) )}})`}上述代码我们可以分两块看下，最外层实际上就是一个立即执行函数表达式，将 modulesTemplateObject 对象传给了 modules。1234((function (modules) { // 这里的 modules 就是最下面传过来的 kv 对象 // ...})(modulesTemplateObject)}再看下 generateModuleTemplate 做了什么，1234567function generateModuleTemplate(code) { // 把每个 JS 文件中的代码块包在一个 function 里 // 将外部的 exports 和 require 传入 function 内 return `function (exports, require) { ${code}}`}接着重头戏来了，我们本篇文章的核心代码，12345678function require(moduleId) { let exports = {}; // 这里用 Object 包裹了 module，使得 module 作为值调用 modules[moduleId](exports, require); return exports;}// 执行第一个 module，也就是 src/index.jsrequire(\"${modules[0].id}\")接着我们将整个过程串起来，123456789101112function webpackMini (fileEntry) { const graph = createGraph(fileEntry) // console.log(graph); const modules = flattenGraph(graph) // console.log(modules); const bundle = createBundle(modules) // console.log(bundle); // 生成文件方法就不在此赘述了 generateFile(bundle)}webpackMini('../src/index.js')执行程序，看看在 dist 目录下是不是得到了 bundle.js。运行 bundle.js ，得到输出：12foo: Hello I am foo!bar.say: Hello I am bar!至此，一个最简单的 JS 模块打包器就完成了！总结回顾一下，我们先是通过 babel 将 JS 字符串转换成了可供分析的语法结构树，然后遍历得到模块间的依赖关系，最后将依赖关系通过我们自己实现的 require 方法加载进来，这样就实现了一个最简单的 JS 模块打包器。后续我们将继续完善代码，诸如打包 commonjs 代码、组件加载缓存、处理组件循环调用等功能。本文的代码保存在 webpack-mini，欢迎 star 关注。","link":"/2019/08/20/build-your-own-js-packer/"},{"title":"从零搭建 Node.js 线上环境","text":"本文对应 Ubuntu 16.04.4 LTS (GNU/Linux 4.4.0-117-generic x86_64)Step 1 更新 Ubuntu 源资源列表1apt-get updateStep 2 安装 Node.js 版本管理工具 nvm我们使用 nvm 作为 Node.js 的版本管理工具，它可以方便的切换 Node.js 版本。1curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.33.11/install.sh | bash看到提示123456789=&gt; Downloading nvm as script to '/root/.nvm'=&gt; Appending nvm source string to /root/.bashrc=&gt; Appending bash_completion source string to /root/.bashrc=&gt; Close and reopen your terminal to start using nvm or run the following to use it now:export NVM_DIR=\"$HOME/.nvm\"[ -s \"$NVM_DIR/nvm.sh\" ] &amp;&amp; \\. \"$NVM_DIR/nvm.sh\" # This loads nvm[ -s \"$NVM_DIR/bash_completion\" ] &amp;&amp; \\. \"$NVM_DIR/bash_completion\" # This loads nvm bash_completion重新登录 Ubuntu。123nvm --version# 显示版本号，证明安装 nvm 已经成功0.33.11Step 3 安装 Node.js1234567891011121314# 列出长期支持的版本nvm ls-remote --lts# 选择安装最新的长期支持版本nvm install v8.11.3# 耐心等待下载，从阿里云上下载的时候速度还是挺慢的Downloading and installing node v8.11.3...Downloading https://nodejs.org/dist/v8.11.3/node-v8.11.3-linux-x64.tar.xz...######################################################################## 100.0%Computing checksum with sha256sumChecksums matched!Now using node v8.11.3 (npm v5.6.0)Creating default alias: default -&gt; v8.11.3Step 4 安装 nginx1apt-get install nginxnginx 默认会被安装在 /etc/nginx 下。安装好之后启动 nginx，访问服务器的 ip，就会看到 nginx 的欢迎页面。12345678# 启动service nginx start# 停止service nginx stop# 重启service nginx restart# 重新加载配置service nginx reloadStep 5 为不同 Node.js 服务配置不同域名假设我们需要配置 www.example.com 指向服务器上的 http://127.0.0.1:8888 ， dev.example.com 指向服务器上的 http://127.0.0.1:8800 。nginx 的默认安装目录是 /etc/nginx ，我们需要在 /etc/nginx/conf.d 下新建两个文件 www.example.com.conf、dev.example.com.conf。www.example.com.conf 内容：12345678server { listen 80; server_name www.example.com; access_log /var/log/nginx/www.example.com.access.log; location / { proxy_pass http://127.0.0.1:8888/; }}dev.example.com.conf 内容：12345678server { listen 80; server_name dev.example.com; access_log /var/log/nginx/dev.example.com.access.log; location / { proxy_pass http://127.0.0.1:8888/; }}12# test 下配置有没有问题nginx -t12# 重新加载配置service nginx reload分别访问下 www 站和 dev 站，看看是不是已经配置好啦！413 Request Entity Too Large 报错解决方式：在 nginx.conf 的 http {} 中添加一个 client_max_body_size 50m; 将上传限制为 50M","link":"/2018/06/22/setup-nodejs-online-server/"},{"title":"免密码 SSH 登录 Linux","text":"由于工作的原因需要经常 SSH 登录服务器，每次登录服务器都要输入一次密码非常麻烦，还好 SSH 提供了免密码登录（公钥登录），设置好之后每次只需要 ssh user@example.com 回车就登录上去了。12# 生成密钥，一路回车，默认保存在 ~/.ssh/id_rsa 下ssh-keygen12# 上传公钥到目标服务器上ssh-copy-id user@example.com12ssh user@example.com# 回车，咻，登录上了！","link":"/2018/06/27/login-linux-without-pwd/"},{"title":"前端基础拾遗之CSS篇","text":"盒子模型CSS 中的每个元素都被表示为一个矩形的盒子，每个盒子有四个边：content edge, padding edge, border edge, and margin edge。box-sizing： content-box(默认)，border-box ，padding-box(deprecated)。content-box 下盒子实际宽度不等于 width，不包括 padding 和 border 部分，布局计算不方便。border-box 下盒子实际宽度与 width 相等。外边距合并(Margin collapsing)块级元素的上外边距和下外边距有时会合并（或折叠）为一个外边距，其大小取其中的最大者，这种行为称为外边距折叠（margin collapsing），有时也翻译为外边距合并。浮动元素和绝对定位元素的外边距不会折叠。上外边距和下外边距在没有 content、padding、border 间隔的情况下相遇，就会发生外边距合并，为其中一个元素添加 content、padding、border 使得上下外边距分离，即可取消叠加。可能发生外边距合并的三种基本情况：相邻元素之间、父元素与其第一个或最后一个子元素之间、空的块级元素。注意：上述情况的组合会产生更复杂的外边距折叠。即使某一外边距为 0，这些规则仍然适用。因此就算父元素的外边距是 0，第一个或最后一个子元素的外边距仍然会“溢出”到父元素的外面，并且使父元素产生边距效果。如果参与折叠的外边距中包含负值，折叠后的外边距的值为最大的正边距与最小的负边距（即绝对值最大的负边距）的和。如果所有参与折叠的外边距都为负，折叠后的外边距的值为最小的负边距的值。这一规则适用于相邻元素和嵌套元素。浮动 float将一个元素放置在 container 的左侧或右侧，允许 text 和 inline 元素环绕它。float 使用块布局，在某些情况下会修改 display 的计算值，inline -&gt; block, inline-block -&gt; block, inline-table -&gt; table, table-cell -&gt; block。对 flex/inline-flex 无效。举个 🌰 float清除浮动清除浮动是为了清除使用浮动元素产生的影响。浮动的元素，高度会塌陷，而高度的塌陷使我们页面后面的布局不能正常显示。clearleft: 元素被向下移动用于清除之前的左浮动。right: 元素被向下移动用于清除之前的右浮动。both: 元素被向下移动用于清除之前的左右浮动。举个 🌰 clearfix、multi-float-clearfix123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051.container { width: 400px; background-color: green; margin: 10px;}.float { float: right; width: 200px; height: 100px; background-color: red;}.container1 { /* overflow: hidden 亦可，各有优缺点 */ overflow: auto;}.container2::after { content: \"\"; display: block; clear: both;}.container3::after { content: \"\"; display: table; clear: both;}.container4 { /* 类似 hardcode */ height: 100px;}.container5::before,.container5::after { content: \"\"; display: table;}.container5::after { clear: both;}.container5 { zoom: 1;}.container6 { /* 父元素浮动也可清除浮动，有副作用 */ float: right;}123456789101112131415161718&lt;div class=\"container container1\"&gt; &lt;div class=\"float\"&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=\"container container2\"&gt; &lt;div class=\"float\"&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=\"container container3\"&gt; &lt;div class=\"float\"&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=\"container container4\"&gt; &lt;div class=\"float\"&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=\"container container5\"&gt; &lt;div class=\"float\"&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=\"container container6\"&gt; &lt;div class=\"float\"&gt;&lt;/div&gt;&lt;/div&gt;块格式化上下文（Block Formatting Context，BFC）浮动元素和绝对定位元素，非块级盒子的块级容器（例如，inline-block、table-cells 和 table-captions），以及 overflow 值不为 visiable 的块级盒子，都会为他们的内容创建新的 BFC（块级格式上下文）。在 BFC 中，盒子从顶端开始垂直地一个接一个地排列，两个盒子之间的垂直的间隙是由他们的 margin 值所决定的。在一个 BFC 中，两个相邻的块级盒子的垂直外边距会产生折叠。在 BFC 中，每一个盒子的左外边缘（margin-left）会触碰到容器的左边缘（border-left）。对于从右到左的格式来说，则触碰到右边缘。BFC 中的元素的布局是不受外界的影响（我们往往利用这个特性来消除浮动元素对其非浮动的兄弟元素和其子元素带来的影响。）并且在一个 BFC 中，块盒与行盒（行盒由一行中所有的内联元素所组成）都会垂直的沿着其父元素的边框排列。动画实现css 实现动画与 js 不同，css 是定义关键帧，js 则是定义渲染页面与运行时间差的关系。css 实现 demosetTimeout 实现 demorequestAnimationFrame 实现 demo选择器选择器的特殊性分成 4 个权重等级：行内样式 +1000id 选择器 +100类、伪类、属性选择器 +10类型、伪元素选择器 +1居中123456// flex 算是最优解，指哪打哪，特别方便.container { display: flex; justify-content: center; align-items: center;}123456// block 元素 margin.block-ele { display: block; margin-left: auto; margin-right: auto;}1234// inline 元素 text-align.inline-ele { text-algin: center;}123456789101112131415// 知道宽高的情况下.container { position: relative;}.child { box-sizing: border-box; position: absolute; height: 50px; width: 100px; top: 50%; left: 50%; margin-top: -25px; margin-left: -50px;}1234567891011121314// 不知道宽高的情况下.container { position: relative;}.child { box-sizing: border-box; position: absolute; height: 60%; width: 50%; top: 50%; left: 50%; transform: translate(-50%, -50%);}css 单位remhtml 元素的 font-size * 当前元素的 rem = 当前元素的 px，响应式布局利器em根据自身的 font-size * 当前元素的 em = 当前元素的 px，按钮根据文字的大小设置对应比例的 padding 比较好用vh1/100 的视口高度，满屏布局的时候比较好用vw1/100 的视口高度vmin / vmaxvh 和 vw 依据于视口的高度和宽度，相对的，vmin 和 vmax 则关于视口高度和宽度两者的最小或者最大值。ex小写 x 的高度ch和数字 0 的宽度响应式布局基于媒体查询和 rem 的响应式布局实践flexa-guide-to-flexboxgridcomplete-guide-gridmeta浏览器引擎前缀CSS 前缀 Edit主流浏览器引擎前缀:-webkit- (谷歌, Safari, 新版 Opera 浏览器等)-moz- (火狐浏览器)-o- (旧版 Opera 浏览器等)-ms- (IE 浏览器 和 Edge 浏览器)API 接口前缀WebKit (谷歌, Safari, 新版 Opera 浏览器等)Moz (火狐浏览器)O (旧版 Opera 浏览器等)MS (IE 浏览器 和 Edge 浏览器)API 属性和方法前缀webkit (谷歌, Safari, 新版 Opera 浏览器等)moz (火狐浏览器)o (旧版 Opera 浏览器等)ms (IE 浏览器 和 Edge 浏览器)页面导入样式时，使用 &lt;link&gt; 和 @import 有什么区别？@import 是 CSS 加载样式的方式， &lt;link&gt; 是 HTML 加载样式的方式。页面被加载的时，&lt;link&gt; 会同时被加载，而 @import 引用的 CSS 会等到页面被加载完再加载。tips 碰撞检测圣杯布局float 实现Flex 实现float 实现真是被 Flex 爆的体无完肤，flex 实现 css 语义清晰，float 满满的黑科技糅杂在一起。MouseEvent offsetX/Y, pageX/Y, clientX/Y, screenX/Ydisplayposition","link":"/2017/07/01/basic-in-css/"},{"title":"前端基础拾遗之HTML篇","text":"DOCTYPE 作用DTD（文档类型定义）是一组机器可读的规则，他定义 XML 或 HTML 的特定版本中允许有什么，不允许有什么。而 DOCTYPE 是用来描述使用哪个 DTD，保证网页以标准模式渲染，一个不含任何 DOCTYPE 的网页将会以 怪异(quirks) 模式渲染。HTML5 之前的 HTML 基于 SGML(Standard Generalized Markup Language, 标准通用标记语言)标准，需要 DTD 来保证在标准模式下渲染。HTML5 只需要 DOCTYPE 就可以保证在标准模式下渲染。浏览器解析 HTML 方式标准模式、怪异模式和部分怪异（近乎标准）模式。在标准模式中，浏览器根据规范显示页面；在混杂模式中，页面以一种比较宽松的向后兼容的方式显示。那些基于 Mozilla 的 Gecko 渲染引擎的，或者 Internet Explorer 8 在 strict mode 下，除了在处理表格的方式上有细微差异外，与标准模式相同。行内元素与块级元素对比内容上，一般情况下，行内元素只能包含数据和其他行内元素。而块级元素可以包含行内元素和其他块级元素。这种结构上的包含继承区别可以使块级元素创建比行内元素更”大型“的结构。格式上，默认情况下，行内元素不会以新行开始，而块级元素会新起一行。行内元素列表一个行内元素只占据它对应标签的边框所包含的空间。b, big, i, small, ttabbr, acronym, cite, code, dfn, em, kbd, strong, samp, vara, bdo, br, img, map, object, q, script, span, sub, supbutton, input, label, select, textarea块级元素列表块级元素占据其父元素（容器）的整个空间，因此创建了一个“块”。12345678910111213141516171819202122232425262728&lt;address&gt; 联系方式信息&lt;article&gt; HTML5 文章内容&lt;aside&gt; HTML5 伴随内容&lt;audio&gt; HTML5 音频播放&lt;blockquote&gt; 块引用&lt;canvas&gt; HTML5 绘制图形&lt;dd&gt; 定义列表中定义条目描述&lt;div&gt; 文档分区&lt;dl&gt; 定义列表&lt;fieldset&gt; 表单元素分组&lt;figcaption&gt; HTML5 图文信息组标题&lt;figure&gt; HTML5 图文信息组&lt;footer&gt; HTML5 区段尾或页尾&lt;form&gt; 表单&lt;h1&gt; , &lt;h2&gt; , &lt;h3&gt; , &lt;h4&gt; , &lt;h5&gt; , &lt;h6&gt; 标题级别 1-6.&lt;header&gt; HTML5 区段头或页头&lt;hgroup&gt; HTML5 标题组&lt;hr&gt; 水平分割线&lt;noscript&gt; 不支持脚本或禁用脚本时显示的内容&lt;ol&gt; 有序列表&lt;output&gt; HTML5 表单输出&lt;p&gt; 行&lt;pre&gt; 预格式化文本&lt;section&gt; HTML5 一个页面区段&lt;table&gt; 表格&lt;tfoot&gt; 表脚注&lt;ul&gt; 无序列表&lt;video&gt; HTML5 视频常见的浏览器内核有哪些？Trident：主要有 IE 浏览器以及多核浏览器Gecko：主要有 Firefox 以及 Firefox 的衍生浏览器WebKit：主要有 Chrome 与 Chrome 的衍生浏览器、Safari 以及多核浏览器Presto：之前主要应用于 Opera，不过现在的 Opera 使用 WebKit 内核EdgeHTML：Microsoft Edge，Trident 的一个分支，移除所有旧版 Internet Explorer 遗留下来的代码，并重写主要的代码以和其他现代浏览器的设计精神互通有无HTML 语义化在程序中, 语义指的是一段代码的含义 — 例如 “这个 HTML 的元素有什么作用，扮演了什么样的角色”。对开发人员及团队，有利于增加代码可读性，减少差异化；对搜索引擎，有助于爬虫抓取更多的有效信息，有利于确定上下文和各个关键字的权重，利于 SEO；对浏览器，即使在 CSS 加载异常的情况下，也能提供一个基础的默认文档样式，方便屏幕阅读器以更有意义的方式渲染。渲染原理浏览器会将 HTML 解析成一个 DOM Tree，DOM Tree的构建过程是一个深度遍历过程：当前节点的所有子节点都构建好后才会去构建当前节点的下一个兄弟节点。将 CSS 解析成 CSS Rule Tree 。根据 DOM Tree 和 CSS Rule Tree 来构造 Rendering Tree。注意：Rendering Tree 渲染树并不等同于 DOM 树，因为一些像 Header 或 display:none 的东西就没必要放在渲染树中了。有了 Render Tree，浏览器已经能知道网页中有哪些节点、各个节点的 CSS 定义以及他们的从属关系。下一步操作称之为 layout，顾名思义就是计算出每个节点在屏幕中的位置。再下一步就是绘制，即遍历 render 树，并使用 UI 后端层绘制每个节点。reflow（回流）：读取或设置位置、尺寸、计算样式等等，都有可能触发 reflow。repaint（重绘）：改变某个元素的背景色、文字颜色、边框颜色等等不影响它周围或内部布局的属性时，屏幕的一部分要重画， 但是元素的几何尺寸没有变。https://gist.github.com/paulirish/5d52fb081b3570c81e3ahttp://www.cnblogs.com/slly/p/6640761.htmlHTTP 超文本传输协议（HyperText Transfer Protocol）HTTP2多路复用、二进制分帧、头部压缩、服务端推送。HTTP/1.x 客户端需要使用多个连接才能实现并发和缩短延迟；HTTP/1.x 不会压缩请求和响应标头，从而导致不必要的网络流量；HTTP/1.x 不支持有效的资源优先级，致使底层 TCP 连接的利用率低下；等等。HTTP/2 通过支持标头字段压缩和在同一连接上进行多个并发交换，让应用更有效地利用网络资源，减少感知的延迟时间。具体来说，它可以对同一连接上的请求和响应消息进行交错发送并为 HTTP 标头字段使用有效编码。 HTTP/2 还允许为请求设置优先级，让更重要的请求更快速地完成，从而进一步提升性能。出台的协议对网络更加友好，因为与 HTTP/1.x 相比，可以使用更少的 TCP 连接。这意味着与其他流的竞争减小，并且连接的持续时间变长，这些特性反过来提高了可用网络容量的利用率。 最后，HTTP/2 还可以通过使用二进制消息分帧对消息进行更高效的处理。https://developers.google.com/web/fundamentals/performance/http2/?hl=zh-cn所有通信都在一个 TCP 连接上完成，此连接可以承载任意数量的双向数据流。每个数据流都有一个唯一的标识符和可选的优先级信息，用于承载双向消息。每条消息都是一条逻辑 HTTP 消息（例如请求或响应），包含一个或多个帧。帧是最小的通信单位，承载着特定类型的数据，例如 HTTP 标头、消息负载，等等。 来自不同数据流的帧可以交错发送，然后再根据每个帧头的数据流标识符重新组装。iframe 优缺点优点：样式隔离，内外样式不会冲突；低改动成本接入其他模块功能；无刷新文件上传；实现长连接，作为 Websocket 不支持浏览器的替代方案缺点：iframe 会阻塞主页面的 onload 事件；搜索引擎的检索程序无法解读这种页面，不利于 SEO；iframe 和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载。Websocket 替代方案DOM BOM 区别DOM 全称是 Document Object Model，也就是文档对象模型，用来操作 HTML 中的元素。例如：document.body、document.getElementById('someid')、document.title = 'Welcome'。BOM 是 Browser Object Model，浏览器对象模型，用来控制浏览器的行为。例如，location.href = &quot;http://www.xxxx.com&quot;、window.reload。DOM1/DOM2/DOM3 区别DOM1 级主要定义了 HTML 和 XML 文档的底层结构。在 DOM1 中，DOM 由两个模块组成：DOM Core（DOM 核心）和 DOM HTML。其中，DOM Core 规定了基于 XML 的文档结构标准，通过这个标准简化了对文档中任意部分的访问和操作。DOM HTML 则在 DOM 核心的基础上加以扩展，添加了针对 HTML 的对象和方法，如：JavaScript 中的 Document 对象.在 DOM1 的基础上 DOM2 引入了更多的交互能力，也支持了更高级的 XML 特性。DOM2 将 DOM 分为更多具有联系的模块。DOM2 级在原来 DOM 的基础上又扩充了鼠标、用户界面事件、范围、遍历等细分模块，而且通过对象接口增加了对 CSS 的支持。DOM1 级中的 DOM 核心模块也经过扩展开始支持 XML 命名空间。DOM3 进一步扩展了 DOM，引入了以统一方式加载和保存文档的方法，它在 DOM Load And Save 这个模块中定义；同时新增了验证文档的方法，是在 DOM Validation 这个模块中定义的。addEventListener、attachEvent、on 区别attachEvent 是 IE8- 添加事件的方法，onclick 会覆盖掉之前绑定的事件，addEventListener 以事件数组的形式添加事件监听，不会覆盖掉之前的事件监听。1,2浏览器前进/后退缓存（Backward/Forward Cache，BF Cache）对整个 web 页面的一个浏览器会话进行了内存缓存，包括他们对 JavaScript 状态。在访问过的页面间后退和前进不需要页面加载同时保存 JavaScript 状态。这个特性，被称为 bfcache（“后退前进缓存”），使得页面导航（切换）非常快。这个状态缓存被保存直到用户关闭浏览器。检测是否被缓存：1234567891011121314window.addEventListener( \"pageshow\", function(event) { console.log(\"event.persisted\" + event.persisted); }, false);window.addEventListener( \"pagehide\", function(event) { console.log(\"event.persisted\" + event.persisted); }, false);https://harttle.land/2017/03/12/backward-forward-cache.htmlhttps://developer.mozilla.org/en-US/docs/Archive/Misc_top_level/Working_with_BFCachehttps://developer.mozilla.org/zh-CN/docs/Mozilla/Firefox/Releases/1.5/Using_Firefox_1.5_caching事件的传播机制 w3c三个阶段：首先进入捕获阶段 Window -&gt;Document-&gt;&lt;html&gt;-&gt;&lt;body&gt;，直到达到目标元素，再进入冒泡阶段，从目标元素反向沿着捕获路径回到 Window。parentNode 和 parentElement 的区别在大部分情况下 parentElement === parentNode，只有在 parentNode 不是 html element 的时候，parentElement = null。12345document.body.parentNode; // the &lt;html&gt; elementdocument.body.parentElement; // the &lt;html&gt; elementdocument.documentElement.parentNode; // the document nodedocument.documentElement.parentElement; // nullchildren(HTMLCollection) 和 childNodes(NodeList) 的区别childNodes 比 children 多包含了几个 text 节点，children 只有 html element。如下图，children[0] === childNodes[1]。document.ready 实现http 302 和 form 表单跳转区别","link":"/2017/07/01/basic-in-html/"},{"title":"在 Terminal 中打开 Sublime","text":"1open ~/.bash_profile1alias sb=\"open -a /Applications/Sublime\\ Text.app\"1source ~/.bash_profilesb. 打开当前文件夹sb file 打开当前已存在文件或文件夹","link":"/2017/05/04/open-sublime-in-terminal/"},{"title":"前端基础拾遗之javascript篇","text":"基本类型继承实现macrotask 和 microtask事件循环每次只会入栈一个 macrotask ，主线程执行完该任务后又会先检查 microtasks 队列并完成里面的所有任务后再执行 macrotask。macrotasks: setTimeout, setInterval, setImmediate, requestAnimationFrame, I/O, UI renderingmicrotasks: process.nextTick, Promises, Object.observe, MutationObserverhttps://juejin.im/entry/58d4df3b5c497d0057eb99ffhttps://stackoverflow.com/questions/25915634/difference-between-microtask-and-macrotask-within-an-event-loop-context#Event Loop浏览器侧1234567891011121314151617181920requestAnimationFrame(() =&gt; { console.log(4);});new Promise((resolve, reject) =&gt; { console.log(1); resolve();}) .then(() =&gt; { console.log(2); throw new Error(\"err\"); }) .catch(() =&gt; { console.log(3); });setTimeout(() =&gt; { console.log(5);}, 0);requestIdleCallback(() =&gt; { console.log(6);});服务端侧，setImmediate 和 setTimeout 触发先后不固定1234567891011121314151617181920new Promise((resolve, reject) =&gt; { console.log(1); resolve();}) .then(() =&gt; { console.log(3); throw new Error(\"err\"); }) .catch(() =&gt; { console.log(4); });setImmediate(() =&gt; { console.log(5);});setTimeout(() =&gt; { console.log(6);}, 0);process.nextTick(() =&gt; { console.log(2);});原型Function.prototype和Function.__proto__都指向Function.prototype，这就是鸡和蛋的问题怎么出现的。Object.prototype.__proto__ === null，说明原型链到Object.prototype终止。1234567891011121314151617function F() {}let f = new F();console.log(f.__proto__ === F.prototype);console.log(F.prototype.constructor === F);console.log(f.constructor === F);console.log(F.__proto__ === Function.prototype);console.log(Function.prototype.constructor === Function);console.log(F.constructor === Function);console.log(Function.__proto__ === Function.prototype);console.log(Function.prototype.constructor === Function);console.log(f.prototype === undefined);console.log(F.prototype.__proto__ === Object.prototype);console.log(Function.prototype.__proto__ === Object.prototype);console.log(Object.prototype.__proto__ === null);依赖数组的方法sliceslice() 方法返回一个从开始到结束（不包括结束）选择的数组的一部分浅拷贝到一个新数组对象。且原始数组不会被修改。12345678arr.slice();// [0, end]arr.slice(begin);// [begin, end]arr.slice(begin, end);// [begin, end)shiftshift() 方法从数组中删除第一个元素，并返回该元素的值。此方法更改数组的长度。不同 TAB 页下通讯BroadcastChannel，Chrome54、Firefox38 Support123456789// tab1const channel = new BroadcastChannel(\"channel-name\");channel.onmessage = function(e) { console.log(e);};// tab2const channel = new BroadcastChannel(\"channel-name\");channel.postMessage(\"some message\");Shared Workers，Chrome、Firefox29 Support1234567891011121314151617181920212223// work.jsconst connections = [];onconnect = function(e) { const port = e.ports[0]; connections.push(port); port.onmessage = function(e) { connections.forEach(function(connection) { if (connection !== port) { connection.postMessage(e.data); } }); };};// tab1const worker = new SharedWorker(\"worker.js\");worker.port.onmessage = function(e) { console.log(e.data);};// tab2const worker = new SharedWorker(\"worker.js\");worker.port.postMessage(\"hello tab1\");localStorage1234567// tab1window.onstorage = function(e) { console.log(e);};// tab2localStorage.setItem(\"key\", \"value\");window.opener","link":"/2017/07/01/basic-in-javascript/"},{"title":"基于媒体查询和 rem 的响应式布局实践","text":"媒体查询 @media我们开发一个网站的时候希望在手机端、iPad 端、PC 端都有良好的体验，CSS 给我们提供了一个强大的条件判断语法，可以根据设备的宽度来设置不同的样式，从而实现不同的设备应用不同的布局。下图展示了利用 @media 实现的同一页面手机端 2 列、iPad 端 3 列、PC 端 4 列的布局。下面我们来分析下如何实现上述 Demo。12345678&lt;div class=\"grid\"&gt; &lt;div class=\"item\"&gt;&lt;/div&gt; &lt;div class=\"item\"&gt;&lt;/div&gt; &lt;div class=\"item\"&gt;&lt;/div&gt; &lt;div class=\"item\"&gt;&lt;/div&gt; &lt;div class=\"item\"&gt;&lt;/div&gt; &lt;div class=\"item\"&gt;&lt;/div&gt;&lt;/div&gt;1234567891011121314151617181920.grid { display: flex; flex-wrap: wrap;}.item { width: 50%;}@media (min-width: 576px) { .item { width: 33.333%; }}@media (min-width: 1024px) { .item { width: 25%; }}我们根据设备的宽度把设备分为三个区间，分别为：小于576px 移动端区间576px~1024px 平板区间大于1024px PC 端区间默认样式针对移动端编写，减少匹配规则，加快移动端的解析。当设备宽度大于 576px 时，就匹配到了 @media (min-width: 576px)，此时 width: 33.333%; 会将原来的 50% 覆盖掉，显示为 3 列。当设备宽度大于 1024px 时，就匹配到了 @media (min-width: 1024px)，此时 width: 25%; 进一步覆盖掉原来的 33.333%，显示为 4 列。通过合理的布局 DOM 结构，可以让不同设备的浏览效果完全不同。配合 flex 布局的 order 属性，DOM 间的位置交换变得更加简单。REM我们使用三个断点解决了不同端的布局问题，但这只是第一步。我们现在还是用的 px 做单位，设计师给我们出的 iPhone6 的设计稿，一个按钮 80px 宽度，iPhone6 上可以这么写。iPhone5s 空间不足导致换行、iPhone6 Plus 留白怎么办？这时候就要召唤出我们的大杀器 rem 了。rem 是一个根据 html 根元素 font-size 计算的相对单位。元素实际尺寸 = 元素 rem 值 x html 的 font-size 值。也就是说当 html 的 font-size 设置为 50px 时，2rem 的元素实际尺寸就是 100px。我司设计师通常使用 2 倍的 iPhone6 作为设计稿。iPhone6 设计稿的宽度为750px，对应实际尺寸350px。为了方便换算，我们将 html 的 font-size 设置为 50px，实际尺寸 100px = 2rem。而这 2rem 正好等于设计稿上的 200 向左移动两位小数点，换算起来非常方便。你说的我都懂，但这跟 5s、6p 适配有什么关系呢？？当然有关系啦，我们可以让 html 的 font-size 基于 iPhone6 等比例缩放，这样就能实现对 5s、6p 的适配。来看一段代码：12var clientWidth = document.documentElement.clientWidth;document.documentElement.style.fontSize = (clientWidth / 750) * 100 + \"px\";计算出当前设备的宽度基于 750 的尺寸，按比例换算成 px，实现不同尺寸的手机设置等比例的 html font-size。我们看下实际效果图：将 @media rem 结合起来将之前讲的两点结合起来，代码如下：123456789var clientWidth = document.documentElement.clientWidth;if (clientWidth &lt; 575) { document.documentElement.style.fontSize = (clientWidth / 750) * 100 + \"px\";} else if (clientWidth &lt; 1024) { // 竖版 iPad 的 2x 尺寸 document.documentElement.style.fontSize = (clientWidth / 1536) * 100 + \"px\";} else { document.documentElement.style.fontSize = \"50px\";}最终实现了：小于576px 移动端区间，按 iPhone6 等比缩放，2 列布局576px~1024px 平板区间，按竖版 iPad 等比缩放，3 列布局大于1024px PC 端区间，不缩放。4 列布局总结，真实的项目中往往比这复杂的多，这个时候就需要把三端的设计稿拿过来仔细分析一下，哪些是可以抽象成一个 DOM 结构，清晰的 DOM 结构会让你的实现更加清晰。附上本文的完整 Demo，也就是一开始的截图。另外更复杂的实现可以参考下我司官网 www.bstcine.com 。","link":"/2018/07/12/responsive-layout-base-media-query-and-rem/"},{"title":"好用的 shell 命令合集","text":"12345678# 设置 proxyalias proxy='export all_proxy=socks5://127.0.0.1:1086'# 取消 proxyalias unproxy='unset all_proxy'# 显示当前 ip 地址alias ip='ifconfig en0|grep \"inet .* netmask\"|cut -d \" \" -f 2'","link":"/2018/06/27/useful-shell-command/"},{"title":"实现一个 react-router","text":"本文将用尽可能容易理解的方式，实现最小可用的 react-router v4 和 history，目的为了了解 react-router 实现原理。一、开始之前在开始阅读本文之前，希望你至少使用过一次 react-router，知道 react-router 的基本使用方法。二、已实现的功能根据当前页面的 location.pathname，渲染对应 Route 中的 component点击 Link，页面无刷新，pathname 更新，渲染对应 Route 中的 component浏览器后退/前进，页面无刷新，渲染对应 Route 中的 component三、Github 地址与在线预览GitHub 地址 build-your-own-react-router在线预览 codesandbox四、原理分析1. Route 的实现先来看一段代码，我们需要实现的逻辑是：当 location.pathname = '/' 时，页面渲染 Index 组件，当 location.path = '/about/' 时，页面渲染 About 组件。1234567891011121314151617181920212223242526272829303132333435363738394041424344import React from 'react';import { BrowserRouter as Router, Route, Link } from \"./react-router-dom\";function Index(props) { console.log('Index props', props); return &lt;h2&gt;Home&lt;/h2&gt;;}function About() { return &lt;h2&gt;About&lt;/h2&gt;;}function Users() { return &lt;h2&gt;Users&lt;/h2&gt;;}function App() { return ( &lt;Router&gt; &lt;div&gt; &lt;nav&gt; &lt;ul&gt; &lt;li&gt; &lt;Link to=\"/\"&gt;Home&lt;/Link&gt; &lt;/li&gt; &lt;li&gt; &lt;Link to=\"/about/\"&gt;About&lt;/Link&gt; &lt;/li&gt; &lt;li&gt; &lt;Link to=\"/users/\"&gt;Users&lt;/Link&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/nav&gt; &lt;Route path=\"/\" exact component={Index} /&gt; &lt;Route path=\"/about/\" component={About} /&gt; &lt;Route path=\"/users/\" component={Users} /&gt; &lt;/div&gt; &lt;/Router&gt; );}export default App;其实，Route 组件内部的核心逻辑就是判断当前 pathname 是否与自身 props 上的 path 相等，如果相等，则渲染自身 props 上的 component，不等的时候不渲染，返回 null。好，来看下 Route 的实现：123456789101112import React from 'react';import { RouterContext } from './BrowserRouter';export default class Route extends React.Component { render() { const { path, component } = this.props; if (this.context.location.pathname !== path) return null; return React.createElement(component, { ...this.context }) }}Route.contextType = RouterContextRoute 主要就是一个 render() 函数，内部通过 context 获得当前 pathname。那么这个 context 是哪来的呢？2. BrowserRouter 的实现1234567891011121314151617181920212223242526import React from 'react';import { createBrowserHistory } from '../history';const history = createBrowserHistory()export const RouterContext = React.createContext(history)export default class BrowserRouter extends React.Component { constructor(props) { super(props) this.state = { location: { pathname: window.location.pathname } } } render() { const { location } = this.state; return ( &lt;RouterContext.Provider value={{ history, location }}&gt; {this.props.children} &lt;/RouterContext.Provider&gt; ) }};这里仅贴出了首次渲染的逻辑代码。BrowserRouter 在 constructor 中根据 window.location 初始化 location，然后将 location 传入 RouterContext.Provider 组件，子组件 Route 接收到含有 location 的 context，根据 1. Route 的实现 完成首次渲染。注意到传入 RouterContext.Provider 组件的对象不光有 location，还有 history 对象。这个 history 是做什么用的呢？其实是暴露 history.push 和 history.listen 方法，提供给外部做跳转和监听跳转事件使用的。Link 组件的实现也是用到了 history，我们接着往下看。3. Link 的实现12345678910111213141516171819202122import React from 'react';import { RouterContext } from './BrowserRouter';export default class Link extends React.Component { constructor(props) { super(props) this.clickHandler = this.clickHandler.bind(this) } clickHandler(e) { console.log('click', this.props.to); e.preventDefault() this.context.history.push(this.props.to) } render() { const { to, children } = this.props; return &lt;a href={to} onClick={this.clickHandler}&gt;{children}&lt;/a&gt; }}Link.contextType = RouterContextLink 组件其实就是一个 a 标签，与普通 a 标签不同，点击 Link 组件并不会刷新整个页面。组件内部把 a 标签的默认行为 preventDefault 了，Link 组件从 context 上拿到 history，将需要跳转的动作告诉 history，即 history.push(to)。如下面代码所示，BrowserRouter 在 componentDidMount 中，通过 history.listen 监听 location 的变化。当 location 变化的时候，setState 一个新的 location 对象，触发 render，进而触发子组件 Route 的重新渲染，渲染出对应 Route。1234567// BrowserRoutercomponentDidMount() { history.listen((pathname) =&gt; { console.log('history change', pathname); this.setState({ location: { pathname } }) })}4. history 的实现history 的内部实现是怎么样的呢？请看下面的代码：12345678910111213141516171819202122232425262728let globalHistory = window.history;export default function createBrowserHistory() { let listeners = [] const push = function (pathname) { globalHistory.pushState({}, '', pathname) notifyListeners(pathname) } const listen = function (listener) { listeners.push(listener) } const notifyListeners = (...args) =&gt; { listeners.forEach(listener =&gt; listener(...args)) } window.onpopstate = function () { notifyListeners(window.location.pathname) } return { listeners, listen, push }};history 通过 listen 方法收集外部的监听事件。当外部调用 history.push 方法时，使用 window.history.pushState 修改当前 location，执行 notifyListeners 方法，依次回调所有的监听事件。注：这里为了让代码更加容易理解，简化了 listener this 上下文的处理。另外，history 内部增加了 window.onpopstate 用来监听浏览器的前进后退事件，执行 notifyListeners 方法。五、总结我们使用了 100 多行代码，实现了 react-router 的基本功能，对 react-router 有了更深入的认识。想更加深入的了解 react-router，建议看一下 react-router 的源码，快速走读一遍，再对比下本文的实现细节，相信你会有一个更清晰的理解。觉得本文帮助到你的话，请给我的 build-your-own-react-router 项目点个⭐️吧！","link":"/2019/09/13/build-your-own-react-router/"},{"title":"如何编写 Babel 插件","text":"目前主流的前端框架在开发的时候都采用最新的 ES6+ 语法，大部分的向下兼容工作都交给了 Babel 来处理。通过引入 Babel 插件，我们可以大胆地使用最新或是正在起草中，甚至是根本不在标准中的 jsx 等语法，跟甚至是你自己胡诌的写法！本文将带大家了解 Babel 是怎么工作的、Babel 插件是怎么工作又是怎么编写的，并写一个与 webpack 集成的最简单的 Babel 插件。Babel 是怎么工作的Babel 是一个 JavaScript 编译器。Babel 通过读取源代码，生成抽象语法树（AST），根据插件对 AST 上对应的节点进行修改，修改完毕后根据新的 AST 输出新的代码。@babel/parse 原名 babylon，Babel 的解析器，用于读取源代码，生成 AST。来看看 import React from &quot;react&quot;; 转换成 AST 后的结构：123456789101112131415161718192021222324252627282930313233{ \"type\": \"Program\", \"start\": 0, \"end\": 26, \"body\": [ { \"type\": \"ImportDeclaration\", \"start\": 0, \"end\": 26, \"specifiers\": [ { \"type\": \"ImportDefaultSpecifier\", \"start\": 7, \"end\": 12, \"local\": { \"type\": \"Identifier\", \"start\": 7, \"end\": 12, \"name\": \"React\" } } ], \"source\": { \"type\": \"Literal\", \"start\": 18, \"end\": 25, \"value\": \"react\", \"raw\": \"\\\"react\\\"\" } } ], \"sourceType\": \"module\"}@babel/traverse，Babel 的遍历器，用于维护 AST 的状态，并且负责替换、移除和添加节点。@babel/types，Babel 的 helper 工具集，包含了构造、验证以及变换 AST 节点的方法。Babel 插件又是怎么工作的Babel 为插件提供了访客模式，可以轻松的访问对应类型的 AST 节点，进行修改。先看一个例子：12345mkdir babel-demo &amp;&amp; cd babel-demonpm i -D @babel/core @babel/typestouch index.js123456789101112131415161718192021// index.jsconst babel = require(\"@babel/core\");const code = 'import React from \"react\";';const visitor = { // 我们要修改的节点是 import 声明节点。 ImportDeclaration(path) { console.log(path.parent.type); console.log(path.node.type); console.log(path.node.specifiers[0].local.name); console.log(path.node.source.value); }};babel.transform(code, { plugins: [ { visitor } ]});1node index.js可以看到 path 的结构是：1234{ \"parent\": { \"type\": \"Program\" }, \"node\": { \"type\": \"ImportDeclaration\" }}通过 node 节点可以访问到当前节点。有同学要问了，我怎么知道我当前要修改的东西是什么类型呢？？先把对应的代码片段贴到 astexplorer，看到该语句是一个 ImportDeclaration，然后到 Babel Spec 查询这个语句的细节文档（这是 Babel 基于 ESTree Spec 做的修改版）。我们要现在把 import React from &quot;react&quot;; 修改成 import React from &quot;vue&quot;;，来看看怎么实现：1234567891011121314151617181920// index.jsconst babel = require(\"@babel/core\");const code = 'import React from \"react\";';const visitor = { ImportDeclaration(path) { path.node.source.value = \"vue\"; }};const res = babel.transform(code, { plugins: [ { visitor } ]});console.log(res.code);// import React from \"vue\";Babel 插件是怎么写的来看看我们写的插件如何集成到 webpack 里，毕竟我们是要拿来用的。123456789// src/index.js// 这里我们打算写一个插件将 &quot;moduleA&quot; 改成 &quot;moduleB&quot;import module from &quot;moduleA&quot;;// src/moduleB.jsexport default () =&gt; { console.log(&quot;B&quot;);};12345// .babelrc{ \"presets\": [[\"@babel/preset-env\"]], \"plugins\": [\"myplugin\"]}Babel 插件的命名方式为 babel-plugin-${your-plugin-name}。npm 打包发布方法可参考 使用 Webpack4.0 打包组件库并发布到 npm 这篇文章，这里为了方便，直接在 node_modules 下写了12345678910// node_modules/babel-plugin-myplugin/index.jsmodule.exports = function() { return { visitor: { ImportDeclaration(path) { path.node.source.value = &quot;./moduleB&quot;; } } };};123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152// dist/main.js/******/ (function(modules) { // webpackBootstrap /******/ // The module cache /******/ var installedModules = {}; // The require function /******/ /******/ /******/ function __webpack_require__(moduleId) { /******/ /******/ // Check if module is in cache /******/ if (installedModules[moduleId]) { /******/ return installedModules[moduleId].exports; /******/ } // Create a new module (and put it into the cache) /******/ /******/ var module = (installedModules[moduleId] = { /******/ i: moduleId, /******/ l: false, /******/ exports: {} /******/ }); // Execute the module function /******/ /******/ /******/ modules[moduleId].call( module.exports, module, module.exports, __webpack_require__ ); // Flag the module as loaded /******/ /******/ /******/ module.l = true; // Return the exports of the module /******/ /******/ /******/ return module.exports; /******/ } // expose the modules object (__webpack_modules__) /******/ /******/ /******/ /******/ __webpack_require__.m = modules; // expose the module cache /******/ /******/ /******/ __webpack_require__.c = installedModules; // define getter function for harmony exports /******/ /******/ /******/ __webpack_require__.d = function(exports, name, getter) { /******/ if (!__webpack_require__.o(exports, name)) { /******/ Object.defineProperty(exports, name, { enumerable: true, get: getter }); /******/ } /******/ }; // define __esModule on exports /******/ /******/ /******/ __webpack_require__.r = function(exports) { /******/ if (typeof Symbol !== \"undefined\" &amp;&amp; Symbol.toStringTag) { /******/ Object.defineProperty(exports, Symbol.toStringTag, { value: \"Module\" }); /******/ } /******/ Object.defineProperty(exports, \"__esModule\", { value: true }); /******/ }; // create a fake namespace object // mode &amp; 1: value is a module id, require it // mode &amp; 2: merge all properties of value into the ns // mode &amp; 4: return value when already ns object // mode &amp; 8|1: behave like require /******/ /******/ /******/ /******/ /******/ /******/ /******/ __webpack_require__.t = function( value, mode ) { /******/ if (mode &amp; 1) value = __webpack_require__(value); /******/ if (mode &amp; 8) return value; /******/ if ( mode &amp; 4 &amp;&amp; typeof value === \"object\" &amp;&amp; value &amp;&amp; value.__esModule ) return value; /******/ var ns = Object.create(null); /******/ __webpack_require__.r(ns); /******/ Object.defineProperty(ns, \"default\", { enumerable: true, value: value }); /******/ if (mode &amp; 2 &amp;&amp; typeof value != \"string\") for (var key in value) __webpack_require__.d( ns, key, function(key) { return value[key]; }.bind(null, key) ); /******/ return ns; /******/ }; // getDefaultExport function for compatibility with non-harmony modules /******/ /******/ /******/ __webpack_require__.n = function(module) { /******/ var getter = module &amp;&amp; module.__esModule ? /******/ function getDefault() { return module[\"default\"]; } : /******/ function getModuleExports() { return module; }; /******/ __webpack_require__.d(getter, \"a\", getter); /******/ return getter; /******/ }; // Object.prototype.hasOwnProperty.call /******/ /******/ /******/ __webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); }; // __webpack_public_path__ /******/ /******/ /******/ __webpack_require__.p = \"\"; // Load entry module and return exports /******/ /******/ /******/ /******/ return __webpack_require__( (__webpack_require__.s = \"./src/index.js\") ); /******/})( /************************************************************************/ /******/ { /***/ \"./src/index.js\": /*!**********************!*\\ !*** ./src/index.js ***! \\**********************/ /*! no static exports found */ /***/ function(module, exports, __webpack_require__) { \"use strict\"; // **关键代码在这里，这里的 moduleA 已经被改成 moduleB 了** eval( '\\n\\nvar _moduleB = _interopRequireDefault(__webpack_require__(/*! ./moduleB */ \"./src/moduleB.js\"));\\n\\nfunction _interopRequireDefault(obj) { return obj &amp;&amp; obj.__esModule ? obj : { default: obj }; }\\n\\n//# sourceURL=webpack:///./src/index.js?' ); /***/ }, /***/ \"./src/moduleB.js\": /*!************************!*\\ !*** ./src/moduleB.js ***! \\************************/ /*! no static exports found */ /***/ function(module, exports, __webpack_require__) { \"use strict\"; eval( '\\n\\nObject.defineProperty(exports, \"__esModule\", {\\n value: true\\n});\\nexports.default = void 0;\\n\\nvar _default = function _default() {\\n console.log(\"B\");\\n};\\n\\nexports.default = _default;\\n\\n//# sourceURL=webpack:///./src/moduleB.js?' ); /***/ } /******/ });可以看到 moduleB 已经被打包进来了。至此，我们最简单的 Babel 插件已经可以正常使用了。感谢&amp;参考：Babel 是如何读懂 JS 代码的Babel Handbookbabel-parser/ast/spec.md剖析 Babel——Babel 总览Babel 内部原理分析astexplorerbabel 插件入门-AST探索 babel 和 babel 插件是怎么工作的babel 到底将代码转换成什么鸟样？分析 Babel 转换 ES6 module 的原理","link":"/2018/07/21/build-you-own-babel-plugin/"},{"title":"常用 MySQL 数据库语句","text":"建表语句1234567891011121314151617CREATE TABLE `t_user` ( `id` varchar(30) NOT NULL COMMENT 'ID', `login` varchar(100) NOT NULL COMMENT '账号', `password` varchar(100) NOT NULL COMMENT '密码', `nickname` varchar(10) DEFAULT NULL COMMENT '昵称', `email` varchar(100) DEFAULT NULL COMMENT '邮箱', `phoneCode` varchar(10) DEFAULT '86' COMMENT '国际电话区号', `phone` varchar(30) DEFAULT NULL COMMENT '手机', `create_at` varchar(24) DEFAULT NULL COMMENT '创建日期', `create_by` varchar(30) DEFAULT NULL COMMENT '创建者', `update_at` varchar(24) DEFAULT NULL COMMENT '修改日期', `update_by` varchar(30) DEFAULT NULL COMMENT '修改者', `delete_at` varchar(24) DEFAULT NULL COMMENT '删除日期', `delete_by` varchar(30) DEFAULT NULL COMMENT '删除者', PRIMARY KEY (`id`), UNIQUE KEY `login` (`login`)) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT='用户表’;增加字段12ALTER TABLE `t_user`ADD COLUMN `qq` VARCHAR(15) DEFAULT NULL COMMENT 'QQ'; -- 增加一个 qq 字段删除字段12ALTER TABLE `t_user`DROP COLUMN `email`; -- 删除一个 email 字段删除索引12ALTER TABLE `t_user`DROP INDEX `login`; -- 删除 login 索引修改字段12ALTER TABLE `t_user`MODIFY COLUMN `nickname` VARCHAR(20) DEFAULT NULL COMMENT '昵称'; -- 修改 nickname 字段长度为 varchar(20)修改字段名称12ALTER TABLE `t_user`CHANGE COLUMN `phoneCode` `phone_code` VARCHAR(10) DEFAULT '86' COMMENT '国际电话区号'; -- 修改 phoneCode 字段为 phone_code在某个字段后面插入一个字段12ALTER TABLE `t_user`ADD COLUMN `wechat` VARCHAR(15) DEFAULT NULL COMMENT '微信' AFTER `phone`; -- 在 phone 字段后添加一个 wechat 字段多条语句连起来写,中端用逗号分隔开123ALTER TABLE `t_user`CHANGE COLUMN `phoneCode` `phone_code` VARCHAR(10) DEFAULT '86' COMMENT '国际电话区号', -- 修改 phoneCode 字段为 phone_codeADD COLUMN `wechat` VARCHAR(15) DEFAULT NULL COMMENT '微信' AFTER `phone`; -- 在 phone 字段后添加一个 wechat 字段删除表1DROP TABLE `t_user`; -- 删除 t_user 表","link":"/2016/12/09/common-sql/"},{"title":"打开 Chrome 的隐藏功能","text":"我们有的时候想查看 Video/Audio 之类的原生控件里面有哪些 DOM 结构或者 CSS 是怎么写的，但是审核元素的时候却看不到里面的结构，那么有没有什么办法看到呢？Chrome 为我们提供了开关 Settings|Preferences -&gt; Elements -&gt; Show user agent shadow DOM，开启之后就能看到隐藏 DOM 了。","link":"/2018/06/27/open-chrome-hidden-tool/"},{"title":"第三方微信登录/注册功能集成-系统流程分析","text":"某日，天空飘来集成第三方微信登录/注册功能的需求，业务侧轻飘飘的一笔带过，表示这个需求很简单，点击登录，就 ok 了。笔者满脸黑线的表示这个功能想做的好，没有用户吐槽的话，需要考虑的情况非常多。以下便是笔者对该功能的需求分析。因文字描述达不到非常清晰地解释，所以以流程图的方式表示。微信登录新页面打开浏览微信注册新页面打开浏览","link":"/2018/08/02/wechat-login-system-design/"},{"title":"记一次 radio 标签 onblur 异常的分析过程","text":"问题版本：Safari 10.0 (12602.1.50.0.10)问题描述：目标版本浏览器在鼠标点击 radio 的小圆点后再点击其他区域并不会触发 onblur 事件。问题可以重现，在 Chrome 下无此问题。1&lt;input type=\"radio\" onblur=\"alert('blur')\"&gt;分析：我们先找到了 w3 上关于 blur 事件的定义：https://www.w3.org/TR/uievents/#event-type-blurA user agent MUST dispatch this event when an event target loses focus. The focus MUST be taken from the element before the dispatch of this event type. This event type is similar to focusout, but is dispatched after focus is shifted, and does not bubble.也就是说，onblur 事件未触发是因为该控件在此之前并没有被 focus ，所以我们在点击 radio 控件的时候监听点击事件，在点击的时候主动触发一下设置 focus1&lt;input type=\"radio\" onblur=\"alert('blur')\" onclick=\"this.focus()\"&gt;问题解决。","link":"/2016/12/09/radio-onblur-troubleshooting/"},{"title":"记一次网站打开缓慢故障排查","text":"问题描述某日，学校用户短时间大量登录学习，网站出现登录不上，无法显示网站内容问题。具体表现为，网站打开迅速，资源加载迅速，但是登录、网站详情内容等涉及 API 的地方显示极慢。定位过程我本地从 wifi 切换到 4G 网络访问网站同样如此，排除服务器及客户端网络问题。查看后台日志，发现对某个日志表的访问量上升，初步定位为数据库问题。登录阿里云 RDS，选择现网实例 –&gt; 日志管理 –&gt; 慢日志明细，查询后发现出现大量慢日志，实例 CPU 占用为 97%，且无下降趋势，问题定位为数据库慢 SQL 问题。解决方法现网实例 –&gt; CloudDBA –&gt; SQL 优化，贴入问题 SQL，选择 SQL 优化诊断，根据给出的索引建议，优化 SQL &amp; 建立索引。观察数据库 CPU 占用，下降，尝试官网访问，正常，问题解决。总结设计用户记录的相关表，一定要预先根据可能出现的查询条件建好索引，定期检查是否有慢 SQL 出现，针对性调整索引。","link":"/2019/04/25/slowly-website-troubleshooting/"},{"title":"阿里云RDS数据恢复方法","text":"某天，公司的数据库被某运维同学用自动化脚本批量改了一批数据，并且改出问题来了，需要恢复修改的数据。由于我司采用了阿里云的云数据库 RDS，于是我登录了公司的阿里云控制台进行了恢复操作，操作过程总结如下，供需要的同学参考。Step 1依次访问菜单“云计算基础服务”&gt;“云数据库 RDS 版” &gt; “实例列表”，选择要恢复的实例 A，点击“管理”，选择“备份恢复”。可以看到 RDS 默认帮我们备份了 1 天前、4 天前、6 天前的数据。Step 2点击“克隆实例”，选择“按量付费”，还原方式选择按“备份集”，备份集选择一天前的那个备份，规格这里可以选择最低的 “1 核 1GB”，因为我们恢复完后就会释放掉这个实例，用不着选特别好的。然后点击“立即购买”。购买完成后需要等待 5 分钟左右，RDS 创建实例还是挺慢的。Step 3新的克隆实例创建好了之后，可以在“云计算基础服务”&gt;“云数据库 RDS 版”&gt;“实例列表”下看到。我们选择新创建的实例，点击“管理”，选择“登录数据库”。输入用户名和密码，点击登录。Step 4登录后就可以看到一天前的数据库的状态，这时候就根据出现的问题，具体问题具体分析，写出恢复的 SQL 语句了。我这次恢复的过程中，发现 1 天前的那个备份也被污染了，于是我又创建了 4 天前的实例，两份数据加一起恢复了现网数据。给运维同学提个醒，最好不要使用自动化脚本刷现网后台，出现问题危害特别大、破坏性极强、恢复困难..","link":"/2018/05/30/aliyun-rds-data-recovery/"}],"tags":[{"name":"API","slug":"API","link":"/tags/API/"},{"name":"mac","slug":"mac","link":"/tags/mac/"},{"name":"linux","slug":"linux","link":"/tags/linux/"},{"name":"MongoDB","slug":"MongoDB","link":"/tags/MongoDB/"},{"name":"Shell","slug":"Shell","link":"/tags/Shell/"},{"name":"database","slug":"database","link":"/tags/database/"},{"name":"javascript","slug":"javascript","link":"/tags/javascript/"},{"name":"PWA","slug":"PWA","link":"/tags/PWA/"},{"name":"Service Worker","slug":"Service-Worker","link":"/tags/Service-Worker/"},{"name":"前端构建","slug":"前端构建","link":"/tags/前端构建/"},{"name":"Prettier","slug":"Prettier","link":"/tags/Prettier/"},{"name":"ESLint","slug":"ESLint","link":"/tags/ESLint/"},{"name":"React","slug":"React","link":"/tags/React/"},{"name":"跨平台通信","slug":"跨平台通信","link":"/tags/跨平台通信/"},{"name":"vim","slug":"vim","link":"/tags/vim/"},{"name":"Bash","slug":"Bash","link":"/tags/Bash/"},{"name":"webpack","slug":"webpack","link":"/tags/webpack/"},{"name":"build your own","slug":"build-your-own","link":"/tags/build-your-own/"},{"name":"bind","slug":"bind","link":"/tags/bind/"},{"name":"cloc","slug":"cloc","link":"/tags/cloc/"},{"name":"setState","slug":"setState","link":"/tags/setState/"},{"name":"Article","slug":"Article","link":"/tags/Article/"},{"name":"event loop","slug":"event-loop","link":"/tags/event-loop/"},{"name":"Git","slug":"Git","link":"/tags/Git/"},{"name":"npm","slug":"npm","link":"/tags/npm/"},{"name":"proxy","slug":"proxy","link":"/tags/proxy/"},{"name":"RegExp","slug":"RegExp","link":"/tags/RegExp/"},{"name":"html5","slug":"html5","link":"/tags/html5/"},{"name":"audio","slug":"audio","link":"/tags/audio/"},{"name":"故障排查","slug":"故障排查","link":"/tags/故障排查/"},{"name":"Parcel","slug":"Parcel","link":"/tags/Parcel/"},{"name":"CSS","slug":"CSS","link":"/tags/CSS/"},{"name":"ubuntu","slug":"ubuntu","link":"/tags/ubuntu/"},{"name":"nginx","slug":"nginx","link":"/tags/nginx/"},{"name":"https","slug":"https","link":"/tags/https/"},{"name":"node.js","slug":"node-js","link":"/tags/node-js/"},{"name":"ssh","slug":"ssh","link":"/tags/ssh/"},{"name":"HTML","slug":"HTML","link":"/tags/HTML/"},{"name":"rem","slug":"rem","link":"/tags/rem/"},{"name":"media-query","slug":"media-query","link":"/tags/media-query/"},{"name":"react-router","slug":"react-router","link":"/tags/react-router/"},{"name":"Babel","slug":"Babel","link":"/tags/Babel/"},{"name":"MySQL","slug":"MySQL","link":"/tags/MySQL/"},{"name":"Chrome","slug":"Chrome","link":"/tags/Chrome/"},{"name":"微信登录","slug":"微信登录","link":"/tags/微信登录/"},{"name":"微信注册","slug":"微信注册","link":"/tags/微信注册/"},{"name":"公众号开发","slug":"公众号开发","link":"/tags/公众号开发/"},{"name":"radio","slug":"radio","link":"/tags/radio/"},{"name":"aliyun","slug":"aliyun","link":"/tags/aliyun/"},{"name":"RDS","slug":"RDS","link":"/tags/RDS/"}],"categories":[{"name":"系统设计","slug":"系统设计","link":"/categories/系统设计/"},{"name":"工具","slug":"工具","link":"/categories/工具/"},{"name":"DevOps","slug":"DevOps","link":"/categories/DevOps/"},{"name":"前端","slug":"前端","link":"/categories/前端/"}]}